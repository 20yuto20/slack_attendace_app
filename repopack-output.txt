This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-10T01:19:53.400Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
attendance/
  .gitignore
  main.py
  requirements.txt
  schema.py
config/
  check_config.py
  config.yaml
src/
  models/
    attendance.py
  repositories/
    firestore_repository.py
  services/
    attendance_service.py
    monthly_summary_service.py
  slack/
    commands/
      attendance_commands.py
      summary_commands.py
    app.py
    message_builder.py
  utils/
    time_utils.py
  config.py
  main.py
.firebaserc
.gitignore
firestore.rules
requirements.txt
Stracture.md

================================================================
Repository Files
================================================================

================
File: attendance/.gitignore
================
*.local

================
File: attendance/main.py
================
# Welcome to Cloud Functions for Firebase for Python!
# To get started, simply uncomment the below code or create your own.
# Deploy with `firebase deploy`

from firebase_functions import https_fn
from firebase_admin import initialize_app

# initialize_app()
#
#
# @https_fn.on_request()
# def on_request_example(req: https_fn.Request) -> https_fn.Response:
#     return https_fn.Response("Hello world!")

================
File: attendance/requirements.txt
================
firebase_functions~=0.1.0

================
File: attendance/schema.py
================
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List

@dataclass
class Attendance:
    """å‡ºå‹¤è¨˜éŒ²ã®ã‚¹ã‚­ãƒ¼ãƒå®šç¾©"""
    user_id: str
    user_name: str
    start_time: datetime
    end_time: Optional[datetime] = None
    total_break_time: float = 0.0  # ä¼‘æ†©æ™‚é–“ã®åˆè¨ˆï¼ˆåˆ†ï¼‰

    def to_dict(self) -> dict:
        return {
            "user_id": self.user_id,
            "user_name": self.user_name,
            "start_time": start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "total_break_time": self.total_break_time
        }

@dataclass
class BreakTime:
    """ä¼‘æ†©æ™‚é–“ã®ã‚¹ã‚­ãƒ¼ãƒå®šç¾©"""
    attendance_id: str
    start_time: datetime
    end_time: Optional[datetime] = None
    
    def to_dict(self) -> dict:
        return {
            "attendance_id": self.attendance_id,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None
        }

================
File: config/check_config.py
================
#!/usr/bin/env python
# src/cli/check_config.py

import os
import sys
from pathlib import Path
from typing import Dict, List, Tuple
import logging
from dataclasses import dataclass
from colorama import init, Fore, Style
from dotenv import load_dotenv  # dotenvã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

# ã‚«ãƒ©ãƒ¼å‡ºåŠ›ã®åˆæœŸåŒ–
init()

# .envãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
load_dotenv()  # ã“ã®è¡Œã‚’è¿½åŠ 

@dataclass
class ConfigCheckResult:
    name: str
    value: str
    exists: bool
    is_file_exists: bool = None
    
    def get_status_color(self) -> str:
        if self.exists:
            if self.is_file_exists is None:
                return Fore.GREEN
            elif self.is_file_exists:
                return Fore.GREEN
            else:
                return Fore.RED
        return Fore.RED

    def get_status_symbol(self) -> str:
        if self.exists:
            if self.is_file_exists is None:
                return "âœ“"
            elif self.is_file_exists:
                return "âœ“"
            else:
                return "Ã—"
        return "Ã—"

def check_env_vars() -> List[ConfigCheckResult]:
    """ç’°å¢ƒå¤‰æ•°ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦çµæœã‚’è¿”ã™"""
    required_vars = {
        "SLACK_BOT_TOKEN": "Slackãƒœãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³",
        "SLACK_SIGNING_SECRET": "Slackç½²åã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ",
        "SLACK_APP_TOKEN": "Slackã‚¢ãƒ—ãƒªãƒˆãƒ¼ã‚¯ãƒ³",
        "FIREBASE_PROJECT_ID": "Firebaseãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆid",
        "FIREBASE_CREDENTIALS_PATH": "Firebaseèªè¨¼æƒ…å ±ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹"
    }
    
    results = []
    
    for var, description in required_vars.items():
        value = os.getenv(var, '')
        exists = bool(value)
        
        # Firebaseèªè¨¼æƒ…å ±ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ã‚‚ãƒã‚§ãƒƒã‚¯
        is_file_exists = None
        if var == "FIREBASE_CREDENTIALS_PATH" and exists:
            is_file_exists = Path(value).exists()
        
        results.append(ConfigCheckResult(
            name=var,
            value=value[:20] + '...' if value and len(value) > 20 else value,
            exists=exists,
            is_file_exists=is_file_exists
        ))
    
    return results

def main():
    """ãƒ¡ã‚¤ãƒ³å‡¦ç†"""
    try:
        # ç¾åœ¨ã®ãƒ‘ã‚¹ã‚’è¡¨ç¤º
        print(f"{Fore.CYAN}ç¾åœ¨ã®ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª:{Style.RESET_ALL} {os.getcwd()}")
        print(f"{Fore.CYAN}.envãƒ•ã‚¡ã‚¤ãƒ«ã®å ´æ‰€:{Style.RESET_ALL} {os.path.join(os.getcwd(), '.env')}")
        
        # .envãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
        env_path = Path(os.getcwd()) / '.env'
        if not env_path.exists():
            print(f"\n{Fore.RED}Warning: .envãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“{Style.RESET_ALL}")
        
        print("\n=== ç’°å¢ƒå¤‰æ•°ãƒã‚§ãƒƒã‚¯ ===\n")
        
        results = check_env_vars()
        
        # çµæœã®è¡¨ç¤º
        for result in results:
            status_color = result.get_status_color()
            status_symbol = result.get_status_symbol()
            
            print(f"{status_color}{status_symbol}{Style.RESET_ALL} {result.name}: ", end='')
            
            if result.exists:
                print(f"{Fore.CYAN}{result.value}{Style.RESET_ALL}")
                if result.is_file_exists is not None and not result.is_file_exists:
                    print(f"  {Fore.RED}Warning: ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}æœªè¨­å®š{Style.RESET_ALL}")
        
        # æˆåŠŸãƒ»å¤±æ•—ã®åˆ¤å®š
        all_success = all(r.exists and (r.is_file_exists is None or r.is_file_exists) for r in results)
        
        print("\n=== ãƒã‚§ãƒƒã‚¯çµæœ ===")
        if all_success:
            print(f"{Fore.GREEN}âœ“ ã™ã¹ã¦ã®è¨­å®šãŒæ­£å¸¸ã§ã™{Style.RESET_ALL}")
            sys.exit(0)
        else:
            print(f"{Fore.RED}Ã— ä¸€éƒ¨ã®è¨­å®šã«å•é¡ŒãŒã‚ã‚Šã¾ã™{Style.RESET_ALL}")
            sys.exit(1)
            
    except Exception as e:
        print(f"{Fore.RED}ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}{Style.RESET_ALL}")
        sys.exit(1)

if __name__ == "__main__":
    main()

================
File: config/config.yaml
================
slack:
  bot_token: "${SLACK_BOT_TOKEN}"
  signing_secret: "${SLACK_SIGNING_SECRET}"
  app_token: "${SLACK_APP_TOKEN}"

firebase:
  project_id: "slack-attendance-bot-4a3a5"
  credentials_path: "config/firebase-credentials.json"

application:
  timezone: "Asia/Tokyo"

================
File: src/models/attendance.py
================
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional

@dataclass
class BreakPeriod:
    start_time: datetime
    end_time: Optional[datetime] = None

    def get_duration(self) -> float:
        """ä¼‘æ†©æ™‚é–“ã‚’åˆ†å˜ä½ã§è¨ˆç®—"""
        if not self.end_time:
            return 0.0
        duration = (self.end_time - self.start_time).total_seconds() / 60
        return round(duration, 2)

@dataclass
class Attendance:
    user_id: str
    user_name: str
    start_time: datetime
    end_time: Optional[datetime] = None
    break_periods: List[BreakPeriod] = None

    def __post_init__(self):
        if self.break_periods is None:
            self.break_periods = []

    def get_total_break_time(self) -> float:
        """ç·ä¼‘æ†©æ™‚é–“ã‚’åˆ†å˜ä½ã§è¨ˆç®—"""
        return sum(period.get_duration() for period in self.break_periods)

    def get_working_time(self) -> float:
        """å®ŸåŠ´åƒæ™‚é–“ã‚’åˆ†å˜ä½ã§è¨ˆç®—ï¼ˆä¼‘æ†©æ™‚é–“ã‚’é™¤ãï¼‰"""
        if not self.end_time:
            return 0.0
        total_duration = (self.end_time - self.start_time).total_seconds() / 60
        return round(total_duration - self.get_total_break_time(), 2)

    def to_dict(self) -> dict:
        """Firestoreã«ä¿å­˜ã™ã‚‹ãŸã‚ã®dictå½¢å¼ã«å¤‰æ›"""
        return {
            "user_id": self.user_id,
            "user_name": self.user_name,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "break_periods": [
                {
                    "start_time": period.start_time.isoformat(),
                    "end_time": period.end_time.isoformat() if period.end_time else None
                }
                for period in self.break_periods
            ]
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'Attendance':
        """dictå½¢å¼ã‹ã‚‰Attendanceã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆ"""
        break_periods = [
            BreakPeriod(
                start_time=datetime.fromisoformat(period["start_time"]),
                end_time=datetime.fromisoformat(period["end_time"]) if period.get("end_time") else None
            )
            for period in data.get("break_periods", [])
        ]
        return cls(
            user_id=data["user_id"],
            user_name=data["user_name"],
            start_time=datetime.fromisoformat(data["start_time"]),
            end_time=datetime.fromisoformat(data["end_time"]) if data.get("end_time") else None,
            break_periods=break_periods
        )

================
File: src/repositories/firestore_repository.py
================
import firebase_admin
from firebase_admin import credentials, firestore
from datetime import datetime
from typing import Optional, List, Dict, Any
from google.cloud.firestore_v1.base_query import FieldFilter, And, Or

from src.models.attendance import Attendance  # çµ¶å¯¾ãƒ‘ã‚¹ã«ä¿®æ­£
from src.utils.time_utils import get_current_time

class FirestoreRepository:
    def __init__(self, project_id: str, credentials_path: str):
        cred = credentials.Certificate(credentials_path)
        firebase_admin.initialize_app(cred, {
            'projectId': project_id,
        })
        self.db = firestore.client()
        self.attendance_collection = self.db.collection('attendance')

    def create_attendance(self, attendance: Attendance) -> None:
        """æ–°ã—ã„å‹¤æ€ è¨˜éŒ²ã‚’ä½œæˆ"""
        doc_ref = self.attendance_collection.document()
        doc_ref.set(attendance.to_dict())

    def get_active_attendance(self, user_id: str) -> Optional[Attendance]:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªï¼ˆçµ‚äº†ã—ã¦ã„ãªã„ï¼‰å‹¤æ€ è¨˜éŒ²ã‚’å–å¾—"""
        query = (
            self.attendance_collection
            .where(filter=firestore.FieldFilter("user_id", "==", user_id))
            .where(filter=firestore.FieldFilter("end_time", "==", None))
            .limit(1)
        )
        docs = query.get()
        
        for doc in docs:
            return Attendance.from_dict(doc.to_dict())
        return None

    def update_attendance(self, attendance: Attendance) -> None:
        """å‹¤æ€ è¨˜éŒ²ã‚’æ›´æ–°"""
        query = (
            self.attendance_collection
            .where(filter=firestore.FieldFilter("user_id", "==", attendance.user_id))
            .where(filter=firestore.FieldFilter("end_time", "==", None))
            .limit(1)
        )
        docs = query.get()
        
        for doc in docs:
            doc.reference.set(attendance.to_dict())
            break

    def get_attendance_by_period(
        self, 
        user_id: str, 
        start_date: datetime, 
        end_date: datetime,
        batch_size: int = 100
    ) -> List[Attendance]:
        """
        æŒ‡å®šæœŸé–“ã®å‹¤æ€ è¨˜éŒ²ã‚’å–å¾—
        
        Args:
            user_id (str): ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
            start_date (datetime): æœŸé–“é–‹å§‹æ—¥æ™‚
            end_date (datetime): æœŸé–“çµ‚äº†æ—¥æ™‚
            batch_size (int): 1å›ã®ã‚¯ã‚¨ãƒªã§å–å¾—ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•°
            
        Returns:
            List[Attendance]: å‹¤æ€ è¨˜éŒ²ã®ãƒªã‚¹ãƒˆ
        
        Raises:
            FirebaseError: Firestoreã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ãŸå ´åˆ
        """
        try:
            # ã‚¯ã‚¨ãƒªã®æ§‹ç¯‰
            query = (
                self.attendance_collection
                .where(filter=FieldFilter("user_id", "==", user_id))
                .where(filter=FieldFilter("start_time", ">=", start_date.isoformat()))
                .where(filter=FieldFilter("start_time", "<=", end_date.isoformat()))
                .order_by("start_time")
                .limit(batch_size)
            )
            
            records = []
            docs = query.get()
            
            # ãƒãƒƒãƒå‡¦ç†ã§ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            while docs:
                records.extend([self._convert_to_attendance(doc) for doc in docs])
                
                # æ¬¡ã®ãƒãƒƒãƒãŒã‚ã‚‹ã‹ç¢ºèª
                last_doc = docs[-1]
                docs = (
                    query
                    .start_after(last_doc)
                    .get()
                )
            
            return records
            
        except Exception as e:
            print(f"Error retrieving attendance records: {str(e)}")
            raise

    def _convert_to_attendance(self, doc: firestore.DocumentSnapshot) -> Attendance:
        """
        Firestoreã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‹¤æ€ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›
        
        Args:
            doc (DocumentSnapshot): Firestoreã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
            
        Returns:
            Attendance: å¤‰æ›ã•ã‚ŒãŸå‹¤æ€ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        """
        data = doc.to_dict()
        return Attendance.from_dict(data)

    def get_attendance_stats(
        self, 
        user_id: str, 
        start_date: datetime, 
        end_date: datetime
    ) -> Dict[str, Any]:
        """
        æŒ‡å®šæœŸé–“ã®å‹¤æ€ çµ±è¨ˆã‚’å–å¾—
        
        Args:
            user_id (str): ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
            start_date (datetime): æœŸé–“é–‹å§‹æ—¥æ™‚
            end_date (datetime): æœŸé–“çµ‚äº†æ—¥æ™‚
            
        Returns:
            Dict[str, Any]: çµ±è¨ˆæƒ…å ±
        """
        records = self.get_attendance_by_period(user_id, start_date, end_date)
        
        total_working_time = 0
        total_break_time = 0
        daily_stats = {}
        
        for record in records:
            date_key = record.start_time.date().isoformat()
            
            if date_key not in daily_stats:
                daily_stats[date_key] = {
                    'working_time': 0,
                    'break_time': 0,
                    'attendance_count': 0
                }
            
            daily_stats[date_key]['working_time'] += record.get_working_time()
            daily_stats[date_key]['break_time'] += record.get_total_break_time()
            daily_stats[date_key]['attendance_count'] += 1
            
            total_working_time += record.get_working_time()
            total_break_time += record.get_total_break_time()
        
        return {
            'total_working_time': total_working_time,
            'total_break_time': total_break_time,
            'daily_stats': daily_stats,
            'record_count': len(records)
        }

================
File: src/services/attendance_service.py
================
from datetime import datetime
from typing import Optional, Tuple

from src.models.attendance import Attendance, BreakPeriod
from src.repositories.firestore_repository import FirestoreRepository
from src.utils.time_utils import get_current_time

class AttendanceService:
    def __init__(self, repository: FirestoreRepository):
        self.repository = repository

    def punch_in(self, user_id: str, user_name: str) -> Tuple[bool, str, Optional[datetime]]:
        """å‡ºå‹¤å‡¦ç†"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if active_attendance:
            return False, "æ—¢ã«å‡ºå‹¤æ¸ˆã¿ã§ã™ã€‚", None

        current_time = get_current_time()
        attendance = Attendance(
            user_id=user_id,
            user_name=user_name,
            start_time=current_time
        )
        self.repository.create_attendance(attendance)
        return True, "å‡ºå‹¤ã‚’è¨˜éŒ²ã—ã¾ã—ãŸã€‚", current_time

    def punch_out(self, user_id: str) -> Tuple[bool, str, Optional[Attendance]]:
        """é€€å‹¤å‡¦ç†"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "å‡ºå‹¤è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", None

        if active_attendance.break_periods and not active_attendance.break_periods[-1].end_time:
            return False, "ä¼‘æ†©ä¸­ã¯é€€å‹¤ã§ãã¾ã›ã‚“ã€‚ã¾ãšä¼‘æ†©ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚", None

        active_attendance.end_time = get_current_time()
        self.repository.update_attendance(active_attendance)
        return True, "é€€å‹¤ã‚’è¨˜éŒ²ã—ã¾ã—ãŸã€‚", active_attendance

    def start_break(self, user_id: str) -> Tuple[bool, str, Optional[datetime]]:
        """ä¼‘æ†©é–‹å§‹å‡¦ç†"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "å‡ºå‹¤è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", None

        if active_attendance.break_periods and not active_attendance.break_periods[-1].end_time:
            return False, "æ—¢ã«ä¼‘æ†©ä¸­ã§ã™ã€‚", None

        current_time = get_current_time()
        active_attendance.break_periods.append(BreakPeriod(start_time=current_time))
        self.repository.update_attendance(active_attendance)
        return True, "ä¼‘æ†©ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚", current_time

    def end_break(self, user_id: str) -> Tuple[bool, str, Optional[Tuple[datetime, float]]]:
        """ä¼‘æ†©çµ‚äº†å‡¦ç†"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "å‡ºå‹¤è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", None

        if not active_attendance.break_periods or active_attendance.break_periods[-1].end_time:
            return False, "ä¼‘æ†©ãŒé–‹å§‹ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", None

        current_time = get_current_time()
        active_attendance.break_periods[-1].end_time = current_time
        break_duration = active_attendance.break_periods[-1].get_duration()
        
        self.repository.update_attendance(active_attendance)
        return True, "ä¼‘æ†©ã‚’çµ‚äº†ã—ã¾ã—ãŸã€‚", (current_time, break_duration)

================
File: src/services/monthly_summary_service.py
================
from datetime import datetime, timedelta
import calendar
import csv
from io import StringIO
from typing import List, Dict, Any, Tuple

from ..models.attendance import Attendance
from ..repositories.firestore_repository import FirestoreRepository
from ..utils.time_utils import get_current_time, get_start_of_month, get_end_of_month

class MonthlySummaryService:
    def __init__(self, repository: FirestoreRepository):
        self.repository = repository

    def get_monthly_summary(self, user_id: str, year: int, month: int) -> Dict[str, Any]:
        """æŒ‡å®šã•ã‚ŒãŸæœˆã®å‹¤æ€ ã‚µãƒãƒªãƒ¼ã‚’å–å¾—"""
        # æœˆã®é–‹å§‹æ—¥ã¨çµ‚äº†æ—¥ã‚’å–å¾—
        start_date = get_start_of_month(year, month)
        end_date = get_end_of_month(year, month)
        
        # æŒ‡å®šæœˆã®å…¨ã¦ã®å‹¤æ€ è¨˜éŒ²ã‚’å–å¾—
        records = self.repository.get_attendance_by_period(user_id, start_date, end_date)
        
        # æ—¥ã”ã¨ã®å‹¤æ€ è¨˜éŒ²ã‚’é›†è¨ˆ
        daily_records = {}
        weekly_totals = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}  # é€±ã”ã¨ã®åˆè¨ˆæ™‚é–“
        total_working_time = 0
        
        for record in records:
            date = record.start_time.date()
            week_number = (date.day - 1) // 7 + 1
            
            if date not in daily_records:
                daily_records[date] = {
                    'working_time': 0,
                    'break_time': 0,
                    'week_number': week_number
                }
            
            working_time = record.get_working_time()
            break_time = record.get_total_break_time()
            
            daily_records[date]['working_time'] += working_time
            daily_records[date]['break_time'] += break_time
            weekly_totals[week_number] += working_time
            total_working_time += working_time

        return {
            'daily_records': daily_records,
            'weekly_totals': weekly_totals,
            'total_working_time': total_working_time,
            'year': year,
            'month': month
        }

    def generate_csv(self, user_id: str, user_name: str, year: int, month: int) -> Tuple[str, str]:
        """æœˆæ¬¡ã‚µãƒãƒªãƒ¼ã®CSVã‚’ç”Ÿæˆ"""
        summary = self.get_monthly_summary(user_id, year, month)
        
        # CSVãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
        filename = f"attendance_summary_{user_name}_{year}_{month:02d}.csv"
        
        # CSVãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
        output = StringIO()
        writer = csv.writer(output)
        
        # ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’æ›¸ãè¾¼ã¿
        writer.writerow(['å¾“æ¥­å“¡å', user_name])
        writer.writerow(['å¹´æœˆ', f'{year}å¹´{month}æœˆ'])
        writer.writerow([])
        writer.writerow(['æ—¥ä»˜', 'æ›œæ—¥', 'å‹¤å‹™æ™‚é–“', 'ä¼‘æ†©æ™‚é–“', 'é€±ç•ªå·'])
        
        # æ—¥ã€…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã¿
        daily_records = summary['daily_records']
        for date in sorted(daily_records.keys()):
            record = daily_records[date]
            writer.writerow([
                date.strftime('%Y-%m-%d'),
                date.strftime('%A'),
                f"{record['working_time']:.2f}",
                f"{record['break_time']:.2f}",
                record['week_number']
            ])
        
        # é€±æ¬¡ã‚µãƒãƒªãƒ¼ã‚’æ›¸ãè¾¼ã¿
        writer.writerow([])
        writer.writerow(['é€±æ¬¡ã‚µãƒãƒªãƒ¼'])
        for week, total in summary['weekly_totals'].items():
            writer.writerow([f'ç¬¬{week}é€±', f'{total:.2f}'])
        
        # æœˆæ¬¡åˆè¨ˆã‚’æ›¸ãè¾¼ã¿
        writer.writerow([])
        writer.writerow(['æœˆé–“åˆè¨ˆå‹¤å‹™æ™‚é–“', f"{summary['total_working_time']:.2f}"])
        
        return filename, output.getvalue()

================
File: src/slack/commands/attendance_commands.py
================
from typing import Callable
from slack_bolt import App

from src.services.attendance_service import AttendanceService
from src.slack.message_builder import MessageBuilder

class AttendanceCommands:
    def __init__(self, app: App, attendance_service: AttendanceService):
        self.app = app
        self.attendance_service = attendance_service
        self._register_commands()

    def _register_commands(self) -> None:
        """ã™ã¹ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²"""
        self._register_command("/punch_in", self._handle_punch_in)
        self._register_command("/punch_out", self._handle_punch_out)
        self._register_command("/break_begin", self._handle_break_begin)
        self._register_command("/break_end", self._handle_break_end)

    def _register_command(self, command: str, handler: Callable) -> None:
        """å€‹åˆ¥ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²"""
        self.app.command(command)(handler)

    async def _handle_punch_in(self, ack, command, say):
        """å‡ºå‹¤ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†"""
        await ack()
        
        success, message, time = self.attendance_service.punch_in(
            user_id=command["user_id"],
            user_name=command["user_name"]
        )

        if success:
            blocks = MessageBuilder.create_punch_in_message(
                username=command["user_name"],
                time=time
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        # ãƒãƒ£ãƒ³ãƒãƒ«å…¨ä½“ã«è¡¨ç¤º
        await say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    async def _handle_punch_out(self, ack, command, say):
        """é€€å‹¤ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†"""
        await ack()
        
        success, message, attendance = self.attendance_service.punch_out(
            user_id=command["user_id"]
        )

        if success:
            blocks = MessageBuilder.create_punch_out_message(
                username=command["user_name"],
                time=attendance.end_time,
                working_time=attendance.get_working_time(),
                total_break_time=attendance.get_total_break_time()
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        # ãƒãƒ£ãƒ³ãƒãƒ«å…¨ä½“ã«è¡¨ç¤º
        await say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    async def _handle_break_begin(self, ack, command, say):
        """ä¼‘æ†©é–‹å§‹ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†"""
        await ack()
        
        success, message, time = self.attendance_service.start_break(
            user_id=command["user_id"]
        )

        if success:
            blocks = MessageBuilder.create_break_start_message(
                username=command["user_name"],
                time=time
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        # ãƒãƒ£ãƒ³ãƒãƒ«å…¨ä½“ã«è¡¨ç¤º
        await say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    async def _handle_break_end(self, ack, command, say):
        """ä¼‘æ†©çµ‚äº†ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†"""
        await ack()
        
        success, message, result = self.attendance_service.end_break(
            user_id=command["user_id"]
        )

        if success:
            time, duration = result
            blocks = MessageBuilder.create_break_end_message(
                username=command["user_name"],
                time=time,
                duration=duration
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        # ãƒãƒ£ãƒ³ãƒãƒ«å…¨ä½“ã«è¡¨ç¤º
        await say(
            blocks=blocks,
            channel=command["channel_id"]
        )

================
File: src/slack/commands/summary_commands.py
================
from datetime import datetime
from typing import Dict, Any, List

from slack_bolt import App
from slack_bolt.async_app import AsyncApp

from ...services.monthly_summary_service import MonthlySummaryService
from ..message_builder import MessageBuilder

class SummaryCommands:
    def __init__(self, app: AsyncApp, summary_service: MonthlySummaryService):
        self.app = app
        self.summary_service = summary_service
        self._register_commands()

    def _register_commands(self) -> None:
        """ã™ã¹ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²"""
        self.app.command("/summary")(self._handle_summary)
        self.app.action("select_month")(self._handle_month_selection)
        self.app.action("download_csv")(self._handle_csv_download)

    async def _handle_summary(self, ack, body, say):
        """ã‚µãƒãƒªãƒ¼ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†"""
        await ack()
        
        current_date = datetime.now()
        blocks = self._create_month_selector_blocks(current_date.year)
        
        await say(
            blocks=blocks,
            channel=body["channel_id"]
        )

    async def _handle_month_selection(self, ack, body, say):
        """æœˆé¸æŠã®å‡¦ç†"""
        await ack()
        
        selected_value = body["actions"][0]["selected_option"]["value"]
        year, month = map(int, selected_value.split("-"))
        
        summary = self.summary_service.get_monthly_summary(
            user_id=body["user"]["id"],
            year=year,
            month=month
        )
        
        blocks = MessageBuilder.create_monthly_summary_message(
            username=body["user"]["name"],
            summary=summary
        )
        
        await say(
            blocks=blocks,
            channel=body["channel"]["id"]
        )

    async def _handle_csv_download(self, ack, body, client):
        """CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã®å‡¦ç†"""
        await ack()
    
        # é¸æŠã•ã‚ŒãŸå¹´æœˆã‚’å–å¾—
        year_month = body["actions"][0]["value"]
        year, month = map(int, year_month.split("-"))
    
        # CSVã‚’ç”Ÿæˆ
        filename, csv_content = self.summary_service.generate_csv(
            user_id=body["user"]["id"],
            user_name=body["user"]["name"],
            year=year,
            month=month
        )
    
        try:
            # files_upload_v2ã‚’ä½¿ç”¨ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            response = await client.files_upload_v2(
                channel=body["channel"]["id"],
                filename=filename,
                content=csv_content,
                title=f"{year}å¹´{month}æœˆã®å‹¤æ€ è¨˜éŒ²",
                initial_comment=f"{year}å¹´{month}æœˆã®å‹¤æ€ è¨˜éŒ²ã‚’CSVã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚"
            )
        
            if not response["ok"]:
                # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                await client.chat_postMessage(
                    channel=body["channel"]["id"],
                    text=f"CSVãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸï¼š{response.get('error', 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼')}"
                )
        except Exception as e:
            # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            await client.chat_postMessage(
                channel=body["channel"]["id"],
                text=f"CSVãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸï¼š{str(e)}"
            )

    def _create_month_selector_blocks(self, year: int) -> List[Dict[str, Any]]:
        """æœˆé¸æŠç”¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½œæˆ"""
        months = []
        for month in range(1, 13):
            months.append({
                "text": {
                    "type": "plain_text",
                    "text": f"{year}å¹´{month}æœˆ"
                },
                "value": f"{year}-{month}"
            })

        return [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "ğŸ“Š *å‹¤æ€ ã‚µãƒãƒªãƒ¼*\nç¢ºèªã—ãŸã„æœˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚"
                }
            },
            {
                "type": "actions",
                "elements": [
                    {
                        "type": "static_select",
                        "placeholder": {
                            "type": "plain_text",
                            "text": "æœˆã‚’é¸æŠ",
                            "emoji": True
                        },
                        "options": months,
                        "action_id": "select_month"
                    }
                ]
            }
        ]

================
File: src/slack/app.py
================
from slack_bolt.async_app import AsyncApp
from slack_bolt.adapter.flask import SlackRequestHandler

from src.services.attendance_service import AttendanceService
from src.services.monthly_summary_service import MonthlySummaryService  # è¿½åŠ 
from src.slack.commands.attendance_commands import AttendanceCommands
from src.slack.commands.summary_commands import SummaryCommands  # è¿½åŠ 

class SlackApp:
    def __init__(
        self,
        bot_token: str,
        signing_secret: str,
        app_token: str,
        attendance_service: AttendanceService,
        monthly_summary_service: MonthlySummaryService
    ):
        self.app = AsyncApp(
            token=bot_token,
            signing_secret=signing_secret
        )
        self.handler = SlackRequestHandler(self.app)
        self.app_token = app_token
        
        # ã‚³ãƒãƒ³ãƒ‰ã®ç™»éŒ²
        AttendanceCommands(self.app, attendance_service)
        SummaryCommands(self.app, monthly_summary_service)

    def get_handler(self) -> SlackRequestHandler:
        return self.handler

    def get_app(self) -> AsyncApp:
        return self.app

================
File: src/slack/message_builder.py
================
from datetime import datetime
from typing import List, Dict, Any

class MessageBuilder:
    @staticmethod
    def format_time(dt: datetime) -> str:
        """æ™‚åˆ»ã‚’è¦‹ã‚„ã™ã„å½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        return dt.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def format_duration(minutes: float) -> str:
        """æ™‚é–“ã‚’æ™‚é–“ã¨åˆ†ã®å½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        hours = int(minutes // 60)
        mins = int(minutes % 60)
        if hours > 0:
            return f"{hours}æ™‚é–“{mins}åˆ†"
        return f"{mins}åˆ†"

    @staticmethod
    def create_punch_in_message(username: str, time: datetime) -> List[Dict[str, Any]]:
        """å‡ºå‹¤ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "ğŸƒ å‡ºå‹¤è¨˜éŒ²",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å¾“æ¥­å“¡:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*å‡ºå‹¤æ™‚åˆ»:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "ä»Šæ—¥ã‚‚ä¸€æ—¥é ‘å¼µã‚Šã¾ã—ã‚‡ã†ï¼ ğŸ‘"
                    }
                ]
            }
        ]

    @staticmethod
    def create_punch_out_message(username: str, time: datetime, working_time: float, total_break_time: float) -> List[Dict[str, Any]]:
        """é€€å‹¤ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "ğŸƒâ€â™‚ï¸ é€€å‹¤è¨˜éŒ²",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å¾“æ¥­å“¡:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*é€€å‹¤æ™‚åˆ»:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å®Ÿåƒæ™‚é–“:*\n{MessageBuilder.format_duration(working_time)}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*ä¼‘æ†©æ™‚é–“:*\n{MessageBuilder.format_duration(total_break_time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼ ğŸŒŸ"
                    }
                ]
            }
        ]

    @staticmethod
    def create_break_start_message(username: str, time: datetime) -> List[Dict[str, Any]]:
        """ä¼‘æ†©é–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "â˜•ï¸ ä¼‘æ†©é–‹å§‹",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å¾“æ¥­å“¡:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*é–‹å§‹æ™‚åˆ»:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "ã‚†ã£ãã‚Šä¼‘æ†©ã—ã¦ãã ã•ã„ ğŸµ"
                    }
                ]
            }
        ]

    @staticmethod
    def create_break_end_message(username: str, time: datetime, duration: float) -> List[Dict[str, Any]]:
        """ä¼‘æ†©çµ‚äº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "â° ä¼‘æ†©çµ‚äº†",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å¾“æ¥­å“¡:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*çµ‚äº†æ™‚åˆ»:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*ä¼‘æ†©æ™‚é–“:*\n{MessageBuilder.format_duration(duration)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "ãã‚Œã§ã¯ã€ä»•äº‹ã«æˆ»ã‚Šã¾ã—ã‚‡ã†ï¼ ğŸ’ª"
                    }
                ]
            }
        ]

    @staticmethod
    def create_error_message(error_message: str) -> List[Dict[str, Any]]:
        """ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        return [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"âš ï¸ *ã‚¨ãƒ©ãƒ¼*: {error_message}"
                }
            }
        ]
    
    @staticmethod
    def create_monthly_summary_message(username: str, summary: Dict[str, Any]) -> List[Dict[str, Any]]:
        """æœˆæ¬¡ã‚µãƒãƒªãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"ğŸ“Š {summary['year']}å¹´{summary['month']}æœˆã®å‹¤æ€ ã‚µãƒãƒªãƒ¼",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å¾“æ¥­å“¡:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*æœˆé–“åˆè¨ˆå‹¤å‹™æ™‚é–“:*\n{MessageBuilder.format_duration(summary['total_working_time'])}"
                    }
                ]
            },
            {
                "type": "divider"
            }
        ]

        # é€±æ¬¡ã‚µãƒãƒªãƒ¼ã‚’è¿½åŠ 
        weekly_fields = []
        for week, total in summary['weekly_totals'].items():
            weekly_fields.append({
                "type": "mrkdwn",
                "text": f"*ç¬¬{week}é€±:*\n{MessageBuilder.format_duration(total)}"
            })

        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": "*é€±æ¬¡ã‚µãƒãƒªãƒ¼*"
            }
        })

        blocks.append({
            "type": "section",
            "fields": weekly_fields
        })

        # CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
        blocks.extend([
            {
                "type": "divider"
            },
            {
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "CSVã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
                            "emoji": True
                        },
                        "value": f"{summary['year']}-{summary['month']}",
                        "action_id": "download_csv",
                        "style": "primary"
                    }
                ]
            }
        ])

        return blocks

================
File: src/utils/time_utils.py
================
from datetime import datetime, timedelta
import calendar
import pytz

from ..config import get_config

def get_current_time() -> datetime:
    """ç¾åœ¨æ™‚åˆ»ã‚’è¨­å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã§å–å¾—"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    return datetime.now(timezone)

def get_start_of_month(year: int, month: int) -> datetime:
    """æœˆåˆæ—¥ã®0æ™‚0åˆ†ã‚’å–å¾—"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    return datetime(year, month, 1, 0, 0, 0, tzinfo=timezone)

def get_end_of_month(year: int, month: int) -> datetime:
    """æœˆæœ«æ—¥ã®23æ™‚59åˆ†59ç§’ã‚’å–å¾—"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    
    # æœˆæœ«æ—¥ã‚’å–å¾—
    _, last_day = calendar.monthrange(year, month)
    
    return datetime(year, month, last_day, 23, 59, 59, tzinfo=timezone)

def get_week_number(date: datetime) -> int:
    """æ—¥ä»˜ã‹ã‚‰é€±ç•ªå·ã‚’å–å¾—ï¼ˆ1-5ï¼‰"""
    return (date.day - 1) // 7 + 1

================
File: src/config.py
================
import os
from pathlib import Path
from typing import Any
from dotenv import load_dotenv

from omegaconf import OmegaConf

_config = None

def init_config() -> Any:
    """è¨­å®šã‚’åˆæœŸåŒ–"""
    global _config
    
    if _config is not None:
        return _config

    # .envãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
    load_dotenv()
    
    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
    config_path = Path(__file__).parent.parent / "config" / "config.yaml"
    
    # åŸºæœ¬è¨­å®šã®èª­ã¿è¾¼ã¿
    _config = OmegaConf.load(config_path)
    
    # ç’°å¢ƒå¤‰æ•°ã§ä¸Šæ›¸ã
    env_config = OmegaConf.create({
        "slack": {
            "bot_token": os.getenv("SLACK_BOT_TOKEN"),
            "signing_secret": os.getenv("SLACK_SIGNING_SECRET"),
            "app_token": os.getenv("SLACK_APP_TOKEN"),
        },
        "firebase": {
            "project_id": os.getenv("FIREBASE_PROJECT_ID"),
            "credentials_path": os.getenv("FIREBASE_CREDENTIALS_PATH"),
        }
    })
    
    _config = OmegaConf.merge(_config, env_config)
    return _config

def get_config() -> Any:
    """è¨­å®šã‚’å–å¾—"""
    global _config
    if _config is None:
        _config = init_config()
    return _config

================
File: src/main.py
================
import asyncio
from flask import Flask, request
import functions_framework
from slack_bolt.adapter.socket_mode.async_handler import AsyncSocketModeHandler

from src.config import init_config
from src.repositories.firestore_repository import FirestoreRepository
from src.services.attendance_service import AttendanceService
from src.services.monthly_summary_service import MonthlySummaryService
from src.slack.app import SlackApp

# Configuration
config = init_config()

print("Initializing services...")

# Initialize repositories
firestore_repo = FirestoreRepository(
    project_id=config.firebase.project_id,
    credentials_path=config.firebase.credentials_path
)

# Initialize services
attendance_service = AttendanceService(firestore_repo)
monthly_summary_service = MonthlySummaryService(firestore_repo)  # è¿½åŠ 

print("Initializing Slack app...")

# Initialize Slack app
slack_app = SlackApp(
    bot_token=config.slack.bot_token,
    signing_secret=config.slack.signing_secret,
    app_token=config.slack.app_token,
    attendance_service=attendance_service,
    monthly_summary_service=monthly_summary_service  # è¿½åŠ 
)

app = Flask(__name__)
handler = slack_app.get_handler()

@functions_framework.http
def slack_bot(request):
    """Cloud Functionsç”¨ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ"""
    if request.method == "POST":
        # Slackã‹ã‚‰ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†
        return handler.handle(request)
    return "Method not allowed", 405

async def start_socket_mode():
    """Socket Modeãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®èµ·å‹•"""
    try:
        app_handler = AsyncSocketModeHandler(
            app=slack_app.get_app(),
            app_token=config.slack.app_token
        )
        await app_handler.start_async()
    except Exception as e:
        print(f"Error starting socket mode: {e}")
        raise

if __name__ == "__main__":
    print("Starting socket mode...")
    # ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç”¨
    # Socket Modeã®å ´åˆ
    asyncio.run(start_socket_mode())

================
File: .firebaserc
================
{
  "projects": {
    "default": "slack-attendance-bot-4a3a5"
  },
  "targets": {},
  "etags": {}
}

================
File: .gitignore
================
**.log
**.json
.env
config/firebase-credentials.json
.env
__pycache__
*.pyc

================
File: firestore.rules
================
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // attendance ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ«ãƒ¼ãƒ«
    match /attendance/{document} {
      // èªè¨¼ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿èª­ã¿æ›¸ãå¯èƒ½
      allow read, write: if request.auth != null;
      
      // æœˆæ¬¡ãƒ‡ãƒ¼ã‚¿å–å¾—ã®ãŸã‚ã®è¤‡æ•°ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆèª­ã¿å–ã‚Šè¨±å¯
      // start_timeã«åŸºã¥ãã‚¯ã‚¨ãƒªã‚’è¨±å¯
      allow list: if request.auth != null 
        && request.query.limit <= 1000  // 1000ä»¶ã¾ã§ã®åˆ¶é™
        && request.query.orderBy == "start_time";  // start_timeã§ã®ä¸¦ã³æ›¿ãˆã‚’è¨±å¯
    }

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ«ãƒ¼ãƒ« - æ˜ç¤ºçš„ã«è¨±å¯ã•ã‚Œã¦ã„ãªã„ã‚¢ã‚¯ã‚»ã‚¹ã‚’æ‹’å¦
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

================
File: requirements.txt
================
slack-bolt>=1.18.0
slack-sdk>=3.21.3
firebase-admin>=6.2.0
omegaconf>=2.3.0
python-dateutil>=2.8.2
pytz>=2023.3
aiohttp>=3.8.5
functions-framework>=3.4.0
flask>=2.3.3
python-dotenv>=1.0.0

================
File: Stracture.md
================
```
attendance-slack-bot/
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config.yaml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ constants/
â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ attendance.py
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ firestore_repository.py
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ attendance_service.py
â”‚   â”œâ”€â”€ slack/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ app.py
â”‚   â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ attendance_commands.py
â”‚   â”‚   â””â”€â”€ message_builder.py
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ time_utils.py
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md
```
