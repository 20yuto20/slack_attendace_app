This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-25T06:02:11.231Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
functions/
  attendance/
    .gitignore
    main.py
    requirements.txt
    schema.py
  config/
    check_config.py
    config.yaml
  src/
    models/
      attendance.py
    repositories/
      firestore_repository.py
    services/
      attendance_service.py
      monthly_summary_service.py
    slack/
      commands/
        attendance_commands.py
        summary_commands.py
      store/
        firestore_installation_store.py
        firestore_state_store.py
      app.py
      events.py
      message_builder.py
      oauth.py
    utils/
      time_utils.py
    config.py
    main.py
  main.py
  requirements.txt
.firebaserc
.gitignore
firestore.rules

================================================================
Repository Files
================================================================

================
File: functions/attendance/.gitignore
================
*.local

================
File: functions/attendance/main.py
================
# Welcome to Cloud Functions for Firebase for Python!
# To get started, simply uncomment the below code or create your own.
# Deploy with `firebase deploy`

from firebase_functions import https_fn
from firebase_admin import initialize_app

# ()
#
#
# @https_fn.on_request()
# def on_request_example(req: https_fn.Request) -> https_fn.Response:
#     return https_fn.Response("Hello world!")

================
File: functions/attendance/requirements.txt
================
firebase_functions~=0.1.0

================
File: functions/attendance/schema.py
================
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List

@dataclass
class Attendance:
    """出勤記録のスキーマ定義"""
    user_id: str
    user_name: str
    start_time: datetime
    end_time: Optional[datetime] = None
    total_break_time: float = 0.0  # 休憩時間の合計（分）

    def to_dict(self) -> dict:
        return {
            "user_id": self.user_id,
            "user_name": self.user_name,
            "start_time": start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "total_break_time": self.total_break_time
        }

@dataclass
class BreakTime:
    """休憩時間のスキーマ定義"""
    attendance_id: str
    start_time: datetime
    end_time: Optional[datetime] = None
    
    def to_dict(self) -> dict:
        return {
            "attendance_id": self.attendance_id,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None
        }

================
File: functions/config/check_config.py
================
#!/usr/bin/env python

import os
import sys
from pathlib import Path
from typing import List
from dataclasses import dataclass
from colorama import init, Fore, Style
from dotenv import load_dotenv

# カラー出力の初期化
init()

@dataclass
class ConfigCheckResult:
    name: str
    value: str
    exists: bool
    is_file_exists: bool = None
    
    def get_status_color(self) -> str:
        if self.exists:
            if self.is_file_exists is None or self.is_file_exists:
                return Fore.GREEN
            return Fore.RED
        return Fore.RED

    def get_status_symbol(self) -> str:
        if self.exists:
            if self.is_file_exists is None or self.is_file_exists:
                return "✓"
            return "×"
        return "×"

def check_env_vars() -> List[ConfigCheckResult]:
    """環境変数をチェックして結果を返す"""
    required_vars = {
        "SLACK_BOT_TOKEN": "Slackボットトークン",
        "SLACK_SIGNING_SECRET": "Slack署名シークレット",
        "SLACK_CLIENT_ID": "SlackクライアントID",
        "SLACK_CLIENT_SECRET": "Slackクライアントシークレット",
        "APP_FIREBASE_PROJECT_ID": "Firebaseプロジェクトのプロジェクトid",
        "APP_FIREBASE_CREDENTIALS_PATH": "Firebase認証情報ファイルのパス"
    }
    
    results = []
    
    for var, description in required_vars.items():
        value = os.getenv(var, '')
        exists = bool(value)
        
        # Firebase認証情報ファイルの場合は、ファイルの存在もチェック
        is_file_exists = None
        if var == "APP_FIREBASE_CREDENTIALS_PATH" and exists:
            is_file_exists = Path(value).exists()
        
        results.append(ConfigCheckResult(
            name=var,
            value=value[:20] + '...' if value and len(value) > 20 else value,
            exists=exists,
            is_file_exists=is_file_exists
        ))
    
    return results

def main():
    """メイン処理"""
    try:
        # .envファイルを読み込む
        load_dotenv()
        
        print("\n=== 環境変数チェック ===\n")
        
        results = check_env_vars()
        
        # 結果の表示
        for result in results:
            status_color = result.get_status_color()
            status_symbol = result.get_status_symbol()
            
            print(f"{status_color}{status_symbol}{Style.RESET_ALL} {result.name}: ", end='')
            
            if result.exists:
                print(f"{Fore.CYAN}{result.value}{Style.RESET_ALL}")
                if result.is_file_exists is not None and not result.is_file_exists:
                    print(f"  {Fore.RED}Warning: ファイルが存在しません{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}未設定{Style.RESET_ALL}")
        
        # 成功・失敗の判定
        all_success = all(r.exists and (r.is_file_exists is None or r.is_file_exists) for r in results)
        
        print("\n=== チェック結果 ===")
        if all_success:
            print(f"{Fore.GREEN}✓ すべての設定が正常です{Style.RESET_ALL}")
            sys.exit(0)
        else:
            print(f"{Fore.RED}× 一部の設定に問題があります{Style.RESET_ALL}")
            sys.exit(1)
            
    except Exception as e:
        print(f"{Fore.RED}エラーが発生しました: {str(e)}{Style.RESET_ALL}")
        sys.exit(1)

if __name__ == "__main__":
    main()

================
File: functions/config/config.yaml
================
slack:
  bot_token: "${SLACK_BOT_TOKEN}"
  signing_secret: "${SLACK_SIGNING_SECRET}"
  app_token: "${SLACK_APP_TOKEN}"
  client_id: "${SLACK_CLIENT_ID}"
  client_secret: "${SLACK_CLIENT_SECRET}"
  

firebase:
  project_id: "slack-attendance-bot-4a3a5"
  credentials_path: "config/firebase-credentials.json"

application:
  timezone: "Asia/Tokyo"

================
File: functions/src/models/attendance.py
================
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional

@dataclass
class BreakPeriod:
    start_time: datetime
    end_time: Optional[datetime] = None

    def get_duration(self) -> float:
        """休憩時間を分単位で計算"""
        if not self.end_time:
            return 0.0
        duration = (self.end_time - self.start_time).total_seconds() / 60
        return round(duration, 2)

@dataclass
class Attendance:
    user_id: str
    user_name: str
    start_time: datetime
    end_time: Optional[datetime] = None
    break_periods: List[BreakPeriod] = None

    def __post_init__(self):
        if self.break_periods is None:
            self.break_periods = []

    def get_total_break_time(self) -> float:
        """総休憩時間を分単位で計算"""
        return sum(period.get_duration() for period in self.break_periods)

    def get_working_time(self) -> float:
        """実労働時間を分単位で計算（休憩時間を除く）"""
        if not self.end_time:
            return 0.0
        total_duration = (self.end_time - self.start_time).total_seconds() / 60
        return round(total_duration - self.get_total_break_time(), 2)

    def to_dict(self) -> dict:
        """Firestoreに保存するためのdict形式に変換"""
        return {
            "user_id": self.user_id,
            "user_name": self.user_name,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "break_periods": [
                {
                    "start_time": period.start_time.isoformat(),
                    "end_time": period.end_time.isoformat() if period.end_time else None
                }
                for period in self.break_periods
            ]
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'Attendance':
        """dict形式からAttendanceオブジェクトを生成"""
        break_periods = [
            BreakPeriod(
                start_time=datetime.fromisoformat(period["start_time"]),
                end_time=datetime.fromisoformat(period["end_time"]) if period.get("end_time") else None
            )
            for period in data.get("break_periods", [])
        ]
        return cls(
            user_id=data["user_id"],
            user_name=data["user_name"],
            start_time=datetime.fromisoformat(data["start_time"]),
            end_time=datetime.fromisoformat(data["end_time"]) if data.get("end_time") else None,
            break_periods=break_periods
        )

================
File: functions/src/repositories/firestore_repository.py
================
import firebase_admin
from firebase_admin import credentials, firestore
from datetime import datetime
from typing import Optional, List, Dict, Any
from google.cloud.firestore_v1.base_query import FieldFilter, And, Or

from src.models.attendance import Attendance  # 絶対パスに修正
from src.utils.time_utils import get_current_time

class FirestoreRepository:
    def __init__(self, project_id: str, credentials_path: str):
        try:
            cred = credentials.Certificate(credentials_path)
            # アプリが初期化されていない場合のみ初期化
            if not firebase_admin._apps:
                firebase_admin.initialize_app(cred, {
                    'projectId': project_id,
                })
            self.db = firestore.client()
            self.attendance_collection = self.db.collection('attendance')
        except Exception as e:
            print(f"Firebase initialization error: {str(e)}")
            raise

    def create_attendance(self, attendance: Attendance) -> None:
        """新しい勤怠記録を作成"""
        doc_ref = self.attendance_collection.document()
        doc_ref.set(attendance.to_dict())

    def get_active_attendance(self, user_id: str) -> Optional[Attendance]:
        """ユーザーのアクティブな（終了していない）勤怠記録を取得"""
        query = (
            self.attendance_collection
            .where(filter=firestore.FieldFilter("user_id", "==", user_id))
            .where(filter=firestore.FieldFilter("end_time", "==", None))
            .limit(1)
        )
        docs = query.get()
        
        for doc in docs:
            return Attendance.from_dict(doc.to_dict())
        return None

    def update_attendance(self, attendance: Attendance) -> None:
        """勤怠記録を更新"""
        query = (
            self.attendance_collection
            .where(filter=firestore.FieldFilter("user_id", "==", attendance.user_id))
            .where(filter=firestore.FieldFilter("end_time", "==", None))
            .limit(1)
        )
        docs = query.get()
        
        for doc in docs:
            doc.reference.set(attendance.to_dict())
            break

    def get_attendance_by_period(
        self, 
        user_id: str, 
        start_date: datetime, 
        end_date: datetime,
        batch_size: int = 100
    ) -> List[Attendance]:
        """
        指定期間の勤怠記録を取得
        
        Args:
            user_id (str): ユーザーID
            start_date (datetime): 期間開始日時
            end_date (datetime): 期間終了日時
            batch_size (int): 1回のクエリで取得するドキュメント数
            
        Returns:
            List[Attendance]: 勤怠記録のリスト
        
        Raises:
            FirebaseError: Firestoreへのアクセスに失敗した場合
        """
        try:
            # クエリの構築
            query = (
                self.attendance_collection
                .where(filter=FieldFilter("user_id", "==", user_id))
                .where(filter=FieldFilter("start_time", ">=", start_date.isoformat()))
                .where(filter=FieldFilter("start_time", "<=", end_date.isoformat()))
                .order_by("start_time")
                .limit(batch_size)
            )
            
            records = []
            docs = query.get()
            
            # バッチ処理でデータを取得
            while docs:
                records.extend([self._convert_to_attendance(doc) for doc in docs])
                
                # 次のバッチがあるか確認
                last_doc = docs[-1]
                docs = (
                    query
                    .start_after(last_doc)
                    .get()
                )
            
            return records
            
        except Exception as e:
            print(f"Error retrieving attendance records: {str(e)}")
            raise

    def _convert_to_attendance(self, doc: firestore.DocumentSnapshot) -> Attendance:
        """
        Firestoreのドキュメントを勤怠オブジェクトに変換
        
        Args:
            doc (DocumentSnapshot): Firestoreのドキュメント
            
        Returns:
            Attendance: 変換された勤怠オブジェクト
        """
        data = doc.to_dict()
        return Attendance.from_dict(data)

    def get_attendance_stats(
        self, 
        user_id: str, 
        start_date: datetime, 
        end_date: datetime
    ) -> Dict[str, Any]:
        """
        指定期間の勤怠統計を取得
        
        Args:
            user_id (str): ユーザーID
            start_date (datetime): 期間開始日時
            end_date (datetime): 期間終了日時
            
        Returns:
            Dict[str, Any]: 統計情報
        """
        records = self.get_attendance_by_period(user_id, start_date, end_date)
        
        total_working_time = 0
        total_break_time = 0
        daily_stats = {}
        
        for record in records:
            date_key = record.start_time.date().isoformat()
            
            if date_key not in daily_stats:
                daily_stats[date_key] = {
                    'working_time': 0,
                    'break_time': 0,
                    'attendance_count': 0
                }
            
            daily_stats[date_key]['working_time'] += record.get_working_time()
            daily_stats[date_key]['break_time'] += record.get_total_break_time()
            daily_stats[date_key]['attendance_count'] += 1
            
            total_working_time += record.get_working_time()
            total_break_time += record.get_total_break_time()
        
        return {
            'total_working_time': total_working_time,
            'total_break_time': total_break_time,
            'daily_stats': daily_stats,
            'record_count': len(records)
        }

================
File: functions/src/services/attendance_service.py
================
from datetime import datetime
from typing import Optional, Tuple

from src.models.attendance import Attendance, BreakPeriod
from src.repositories.firestore_repository import FirestoreRepository
from src.utils.time_utils import get_current_time

class AttendanceService:
    def __init__(self, repository: FirestoreRepository):
        self.repository = repository

    def punch_in(self, user_id: str, user_name: str) -> Tuple[bool, str, Optional[datetime]]:
        """出勤処理"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if active_attendance:
            return False, "既に出勤済みです。", None

        current_time = get_current_time()
        attendance = Attendance(
            user_id=user_id,
            user_name=user_name,
            start_time=current_time
        )
        self.repository.create_attendance(attendance)
        return True, "出勤を記録しました。", current_time

    def punch_out(self, user_id: str) -> Tuple[bool, str, Optional[Attendance]]:
        """退勤処理"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "出勤記録が見つかりません。", None

        if active_attendance.break_periods and not active_attendance.break_periods[-1].end_time:
            return False, "休憩中は退勤できません。まず休憩を終了してください。", None

        active_attendance.end_time = get_current_time()
        self.repository.update_attendance(active_attendance)
        return True, "退勤を記録しました。", active_attendance

    def start_break(self, user_id: str) -> Tuple[bool, str, Optional[datetime]]:
        """休憩開始処理"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "出勤記録が見つかりません。", None

        if active_attendance.break_periods and not active_attendance.break_periods[-1].end_time:
            return False, "既に休憩中です。", None

        current_time = get_current_time()
        active_attendance.break_periods.append(BreakPeriod(start_time=current_time))
        self.repository.update_attendance(active_attendance)
        return True, "休憩を開始しました。", current_time

    def end_break(self, user_id: str) -> Tuple[bool, str, Optional[Tuple[datetime, float]]]:
        """休憩終了処理"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "出勤記録が見つかりません。", None

        if not active_attendance.break_periods or active_attendance.break_periods[-1].end_time:
            return False, "休憩が開始されていません。", None

        current_time = get_current_time()
        active_attendance.break_periods[-1].end_time = current_time
        break_duration = active_attendance.break_periods[-1].get_duration()
        
        self.repository.update_attendance(active_attendance)
        return True, "休憩を終了しました。", (current_time, break_duration)

================
File: functions/src/services/monthly_summary_service.py
================
from datetime import datetime, timedelta
import calendar
import csv
from io import StringIO
from typing import List, Dict, Any, Tuple

from ..models.attendance import Attendance
from ..repositories.firestore_repository import FirestoreRepository
from ..utils.time_utils import get_current_time, get_start_of_month, get_end_of_month

class MonthlySummaryService:
    def __init__(self, repository: FirestoreRepository):
        self.repository = repository

    def get_monthly_summary(self, user_id: str, year: int, month: int) -> Dict[str, Any]:
        """指定された月の勤怠サマリーを取得"""
        # 月の開始日と終了日を取得
        start_date = get_start_of_month(year, month)
        end_date = get_end_of_month(year, month)
        
        # 指定月の全ての勤怠記録を取得
        records = self.repository.get_attendance_by_period(user_id, start_date, end_date)
        
        # 日ごとの勤怠記録を集計
        daily_records = {}
        weekly_totals = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}  # 週ごとの合計時間
        total_working_time = 0
        
        for record in records:
            date = record.start_time.date()
            week_number = (date.day - 1) // 7 + 1
            
            if date not in daily_records:
                daily_records[date] = {
                    'working_time': 0,
                    'break_time': 0,
                    'week_number': week_number
                }
            
            working_time = record.get_working_time()
            break_time = record.get_total_break_time()
            
            daily_records[date]['working_time'] += working_time
            daily_records[date]['break_time'] += break_time
            weekly_totals[week_number] += working_time
            total_working_time += working_time

        return {
            'daily_records': daily_records,
            'weekly_totals': weekly_totals,
            'total_working_time': total_working_time,
            'year': year,
            'month': month
        }
    
    def _format_time_to_hours_and_minutes(self, minutes: float) -> str:
        hours = int(minutes // 60)
        mins = int(minutes % 60)
        if hours > 0:
            return f"{hours}時間{mins}分"
        return f"{mins}分"
    
    def generate_csv(self, user_id: str, user_name: str, year: int, month: int) -> Tuple[str, str]:
        """月次サマリーのCSVを生成"""
        summary = self.get_monthly_summary(user_id, year, month)
        
        # CSVファイル名を生成
        filename = f"attendance_summary_{user_name}_{year}_{month:02d}.csv"
        
        # CSVデータを生成
        output = StringIO()
        writer = csv.writer(output)
        
        # ヘッダー行を書き込み
        writer.writerow(['従業員名', user_name])
        writer.writerow(['年月', f'{year}年{month}月'])
        writer.writerow([])
        writer.writerow(['日付', '曜日', '勤務時間', '休憩時間', '週番号'])
        
        # 日々のデータを書き込み
        daily_records = summary['daily_records']
        for date in sorted(daily_records.keys()):
            record = daily_records[date]
            writer.writerow([
                date.strftime('%Y-%m-%d'),
                date.strftime('%A'),
                self._format_time_to_hours_and_minutes(record['working_time']),
                self._format_time_to_hours_and_minutes(record['break_time']),
                record['week_number']
            ])
        
        # 週次サマリーを書き込み
        writer.writerow([])
        writer.writerow(['週次サマリー'])
        for week, total in summary['weekly_totals'].items():
            writer.writerow([f'第{week}週', self._format_time_to_hours_and_minutes(total)])
        
        # 月次合計を書き込み
        writer.writerow([])
        writer.writerow(['月間合計勤務時間', self._format_time_to_hours_and_minutes(summary['total_working_time'])])
        
        return filename, output.getvalue()

================
File: functions/src/slack/commands/attendance_commands.py
================
from typing import Callable
from slack_bolt import App

from src.services.attendance_service import AttendanceService
from src.slack.message_builder import MessageBuilder

class AttendanceCommands:
    def __init__(self, app: App, attendance_service: AttendanceService):
        self.app = app
        self.attendance_service = attendance_service
        self._register_commands()

    def _register_commands(self) -> None:
        """すべてのコマンドを登録"""
        self._register_command("/punch_in", self._handle_punch_in)
        self._register_command("/punch_out", self._handle_punch_out)
        self._register_command("/break_begin", self._handle_break_begin)
        self._register_command("/break_end", self._handle_break_end)

    def _register_command(self, command: str, handler: Callable) -> None:
        """個別のコマンドを登録"""
        self.app.command(command)(handler)

    def _handle_punch_in(self, ack, command, say):
        """出勤コマンドの処理"""
        ack()
        
        success, message, time = self.attendance_service.punch_in(
            user_id=command["user_id"],
            user_name=command["user_name"]
        )

        if success:
            blocks = MessageBuilder.create_punch_in_message(
                username=command["user_name"],
                time=time
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    def _handle_punch_out(self, ack, command, say):
        """退勤コマンドの処理"""
        ack()
        
        success, message, attendance = self.attendance_service.punch_out(
            user_id=command["user_id"]
        )

        if success:
            blocks = MessageBuilder.create_punch_out_message(
                username=command["user_name"],
                time=attendance.end_time,
                working_time=attendance.get_working_time(),
                total_break_time=attendance.get_total_break_time()
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    def _handle_break_begin(self, ack, command, say):
        """休憩開始コマンドの処理"""
        ack()
        
        success, message, time = self.attendance_service.start_break(
            user_id=command["user_id"]
        )

        if success:
            blocks = MessageBuilder.create_break_start_message(
                username=command["user_name"],
                time=time
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    def _handle_break_end(self, ack, command, say):
        """休憩終了コマンドの処理"""
        ack()
        
        success, message, result = self.attendance_service.end_break(
            user_id=command["user_id"]
        )

        if success:
            time, duration = result
            blocks = MessageBuilder.create_break_end_message(
                username=command["user_name"],
                time=time,
                duration=duration
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        say(
            blocks=blocks,
            channel=command["channel_id"]
        )

================
File: functions/src/slack/commands/summary_commands.py
================
from datetime import datetime
from typing import Dict, Any, List

from slack_bolt import App

from ...services.monthly_summary_service import MonthlySummaryService
from ..message_builder import MessageBuilder

class SummaryCommands:
    def __init__(self, app: App, summary_service: MonthlySummaryService):
        self.app = app
        self.summary_service = summary_service
        self._register_commands()

    def _register_commands(self) -> None:
        """すべてのコマンドを登録"""
        self.app.command("/summary")(self._handle_summary)
        self.app.action("select_year")(self._handle_year_selection)
        self.app.action("select_month")(self._handle_month_selection)
        self.app.action("download_csv")(self._handle_csv_download)

    def _handle_summary(self, ack, body, say):
        """サマリーコマンドの処理"""
        ack()
        
        current_date = datetime.now()
        # 月選択用のブロックを生成するメソッドを呼び出し
        blocks = self._create_month_selector_blocks(current_date.year)
        
        say(
            blocks=blocks,
            channel=body["channel"]["id"]
        )
    
    def _handle_year_selection(self, ack, body, say):
        """年選択の処理"""
        ack()
        
        selected_value = body["actions"][0]["selected_option"]["value"]
        year = int(selected_value)
        
        blocks = self._create_month_selector_blocks(year)
        say(
            blocks=blocks,
            channel=body["channel"]["id"]
        )

    def _handle_month_selection(self, ack, body, say):
        """月選択の処理"""
        ack()
        
        selected_value = body["actions"][0]["selected_option"]["value"]
        year, month = map(int, selected_value.split("-"))
        
        summary = self.summary_service.get_monthly_summary(
            user_id=body["user"]["id"],
            year=year,
            month=month
        )
        
        blocks = MessageBuilder.create_monthly_summary_message(
            username=body["user"]["name"],
            summary=summary
        )
        
        say(
            blocks=blocks,
            channel=body["channel"]["id"]
        )

    def _handle_csv_download(self, ack, body, client):
        """CSVダウンロードの処理"""
        ack()
    
        year_month = body["actions"][0]["value"]
        year, month = map(int, year_month.split("-"))
    
        filename, csv_content = self.summary_service.generate_csv(
            user_id=body["user"]["id"],
            user_name=body["user"]["name"],
            year=year,
            month=month
        )
    
        try:
            response = client.files_upload_v2(
                channel=body["channel"]["id"],
                filename=filename,
                content=csv_content,
                title=f"{year}年{month}月の勤怠記録",
                initial_comment=f"{year}年{month}月の勤怠記録をCSVでダウンロードしました。"
            )
        
            if not response["ok"]:
                client.chat_postMessage(
                    channel=body["channel"]["id"],
                    text=f"CSVファイルのアップロードに失敗しました：{response.get('error', '不明なエラー')}"
                )
        except Exception as e:
            client.chat_postMessage(
                channel=body["channel"]["id"],
                text=f"CSVファイルのアップロードに失敗しました：{str(e)}"
            )

    def _create_month_selector_blocks(self, current_year: int) -> List[Dict[str, Any]]:
        """
        年と月を選択できるブロックを返すメソッド。
        年は2024年から現在の年まで、月は1月から12月まで選択可能。
        """
        # 年の選択肢を作成
        year_options = []
        for y in range(2024, current_year + 1):
            year_options.append({
                "text": {
                    "type": "plain_text",
                    "text": f"{y}年"
                },
                "value": str(y)
            })

        # 月の選択肢を作成
        month_options = []
        for m in range(1, 13):
            month_options.append({
                "text": {
                    "type": "plain_text",
                    "text": f"{m}月"
                },
                "value": f"{current_year}-{m}"
            })

        blocks = [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "年を選択してください"
                },
                "accessory": {
                    "type": "static_select",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "年を選択"
                    },
                    "options": year_options,
                    "action_id": "select_year"
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "月を選択してください"
                },
                "accessory": {
                    "type": "static_select",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "月を選択"
                    },
                    "options": month_options,
                    "action_id": "select_month"
                }
            }
        ]
        return blocks

================
File: functions/src/slack/store/firestore_installation_store.py
================
from typing import Optional, Dict, Any
import json
from datetime import datetime
from firebase_admin import firestore
from slack_sdk.oauth.installation_store import InstallationStore
from slack_sdk.oauth.installation_store.models.installation import Installation
from slack_sdk.oauth.installation_store.models.bot import Bot

class FirestoreInstallationStore(InstallationStore):
    """Firestoreベースのインストール情報永続化クラス"""
    
    def __init__(self, db: firestore.Client):
        self.db = db
        self.installations_collection = self.db.collection('slack_installations')
        self.bots_collection = self.db.collection('slack_bots')

    def save(self, installation: Installation):
        """インストール情報を保存"""
        # 基本のインストール情報（ユーザーIDありの場合）
        installation_data = {
            'app_id': installation.app_id,
            'enterprise_id': installation.enterprise_id,
            'team_id': installation.team_id,
            'user_id': installation.user_id,
            'bot_token': installation.bot_token,
            'bot_id': installation.bot_id,
            'bot_user_id': installation.bot_user_id,
            'bot_scopes': installation.bot_scopes,
            'user_token': installation.user_token,
            'user_scopes': installation.user_scopes,
            'installed_at': datetime.utcnow(),
            'is_enterprise_install': installation.is_enterprise_install,
        }

        # ユーザーIDありドキュメントID
        user_doc_id = self._generate_installation_id(
            enterprise_id=installation.enterprise_id,
            team_id=installation.team_id,
            is_enterprise_install=installation.is_enterprise_install,
            user_id=installation.user_id
        )
        self.installations_collection.document(user_doc_id).set(installation_data)

        # ボットトークンがある場合、user_idなしのワークスペース/エンタープライズ単位のドキュメントも保存する
        # これにより、user_idを指定しなくてもbotインストール情報が取得可能になる
        if installation.bot_token:
            bot_level_doc_id = self._generate_installation_id(
                enterprise_id=installation.enterprise_id,
                team_id=installation.team_id,
                is_enterprise_install=installation.is_enterprise_install,
                user_id=None  # userなし
            )
            bot_level_data = dict(installation_data)
            bot_level_data['user_id'] = None
            self.installations_collection.document(bot_level_doc_id).set(bot_level_data)

            # Bot情報も保存
            bot_data = {
                'app_id': installation.app_id,
                'enterprise_id': installation.enterprise_id,
                'team_id': installation.team_id,
                'bot_token': installation.bot_token,
                'bot_id': installation.bot_id,
                'bot_user_id': installation.bot_user_id,
                'bot_scopes': installation.bot_scopes,
                'installed_at': datetime.utcnow(),
                'is_enterprise_install': installation.is_enterprise_install,
            }
            
            bot_doc_id = self._generate_bot_id(
                enterprise_id=installation.enterprise_id,
                team_id=installation.team_id,
                is_enterprise_install=installation.is_enterprise_install
            )
            self.bots_collection.document(bot_doc_id).set(bot_data)

    def find_installation(
        self,
        *,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        user_id: Optional[str] = None,
        is_enterprise_install: Optional[bool] = False,
    ) -> Optional[Installation]:
        """インストール情報を検索"""
        doc_id = self._generate_installation_id(
            enterprise_id=enterprise_id,
            team_id=team_id,
            is_enterprise_install=is_enterprise_install,
            user_id=user_id
        )
        
        doc = self.installations_collection.document(doc_id).get()
        if not doc.exists:
            # user_idなしで検索できなかった場合、user_idがNoneでないなら再度Noneで検索
            # ただしSlack Boltはデフォルトでuser_id無し検索を行うことが多いので、
            # user_idが指定されていない場合はこれ以上再検索は不要。
            if user_id is not None:
                # user_idがある検索で見つからなかった場合、user_idなしで再検索してみる
                no_user_doc_id = self._generate_installation_id(
                    enterprise_id=enterprise_id,
                    team_id=team_id,
                    is_enterprise_install=is_enterprise_install,
                    user_id=None
                )
                doc = self.installations_collection.document(no_user_doc_id).get()
                if not doc.exists:
                    return None
                return self._create_installation_from_doc(doc)
            return None
            
        return self._create_installation_from_doc(doc)

    def find_bot(
        self,
        *,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        is_enterprise_install: Optional[bool] = False
    ) -> Optional[Bot]:
        """Bot情報を検索"""
        doc_id = self._generate_bot_id(
            enterprise_id=enterprise_id,
            team_id=team_id,
            is_enterprise_install=is_enterprise_install
        )
        
        doc = self.bots_collection.document(doc_id).get()
        if not doc.exists:
            return None
            
        return self._create_bot_from_doc(doc)

    def delete_installation(
        self,
        *,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        user_id: Optional[str] = None,
        is_enterprise_install: Optional[bool] = False
    ) -> None:
        """インストール情報を削除"""
        doc_id = self._generate_installation_id(
            enterprise_id=enterprise_id,
            team_id=team_id,
            is_enterprise_install=is_enterprise_install,
            user_id=user_id
        )
        
        self.installations_collection.document(doc_id).delete()

        # ボットレベルのドキュメントも削除
        if user_id is not None:
            bot_level_doc_id = self._generate_installation_id(
                enterprise_id=enterprise_id,
                team_id=team_id,
                is_enterprise_install=is_enterprise_install,
                user_id=None
            )
            self.installations_collection.document(bot_level_doc_id).delete()

    def delete_bot(
        self,
        *,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        is_enterprise_install: Optional[bool] = False
    ) -> None:
        """Bot情報を削除"""
        doc_id = self._generate_bot_id(
            enterprise_id=enterprise_id,
            team_id=team_id,
            is_enterprise_install=is_enterprise_install
        )
        
        self.bots_collection.document(doc_id).delete()

    def _generate_installation_id(
        self,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        is_enterprise_install: bool,
        user_id: Optional[str]
    ) -> str:
        """インストール情報のドキュメントID生成"""
        components = []
        if is_enterprise_install and enterprise_id:
            # エンタープライズインストールの場合
            components.append(f"E{enterprise_id}")
            if user_id:
                components.append(f"U{user_id}")
        else:
            # 通常のワークスペースインストール
            if enterprise_id:
                components.append(f"E{enterprise_id}")
            if team_id:
                components.append(f"T{team_id}")
            if user_id:
                components.append(f"U{user_id}")
        return "-".join(components)

    def _generate_bot_id(
        self,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        is_enterprise_install: bool
    ) -> str:
        """BotのドキュメントID生成"""
        components = []
        if is_enterprise_install and enterprise_id:
            components.append(f"E{enterprise_id}")
        else:
            if enterprise_id:
                components.append(f"E{enterprise_id}")
            if team_id:
                components.append(f"T{team_id}")
        return "-".join(components)

    def _create_installation_from_doc(self, doc) -> Installation:
        """FirestoreドキュメントからInstallationオブジェクトを作成"""
        data = doc.to_dict()
        return Installation(
            app_id=data.get('app_id'),
            enterprise_id=data.get('enterprise_id'),
            team_id=data.get('team_id'),
            user_id=data.get('user_id'),
            bot_token=data.get('bot_token'),
            bot_id=data.get('bot_id'),
            bot_user_id=data.get('bot_user_id'),
            bot_scopes=data.get('bot_scopes', []),
            user_token=data.get('user_token'),
            user_scopes=data.get('user_scopes', []),
            is_enterprise_install=data.get('is_enterprise_install', False)
        )

    def _create_bot_from_doc(self, doc) -> Bot:
        """FirestoreドキュメントからBotオブジェクトを作成"""
        data = doc.to_dict()
        return Bot(
            app_id=data.get('app_id'),
            enterprise_id=data.get('enterprise_id'),
            team_id=data.get('team_id'),
            bot_token=data.get('bot_token'),
            bot_id=data.get('bot_id'),
            bot_user_id=data.get('bot_user_id'),
            bot_scopes=data.get('bot_scopes', []),
            is_enterprise_install=data.get('is_enterprise_install', False)
        )

================
File: functions/src/slack/store/firestore_state_store.py
================
from datetime import datetime, timedelta
from typing import Optional
from firebase_admin import firestore
from slack_sdk.oauth.state_store import OAuthStateStore
import secrets

class FirestoreStateStore(OAuthStateStore):
    """Firestoreベースの認証状態管理クラス"""
    
    def __init__(
        self,
        db: firestore.Client,
        expiration_seconds: int = 600
    ):
        self.db = db
        self.expiration_seconds = expiration_seconds
        self.states_collection = self.db.collection('slack_oauth_states')

    def issue(self, expire_in: Optional[int] = None) -> str:
        """
        新しいstateを発行して返す
        
        BoltのOAuthStateStoreでexpectされるインターフェース:
        issue()は引数なしで呼ばれ、state文字列を返すことが求められます。
        """
        if expire_in is None:
            expire_in = self.expiration_seconds
            
        # ランダムなstateを生成
        state = secrets.token_urlsafe(32)
        expire_at = datetime.utcnow() + timedelta(seconds=expire_in)
        
        try:
            self.states_collection.document(state).set({
                'state': state,
                'expire_at': expire_at
            })
            return state
        except Exception as e:
            print(f"Error issuing state: {str(e)}")
            # エラー時は空文字列など返してもよいが、基本的にはraiseする
            raise

    def consume(self, state: str) -> bool:
        """
        状態を検証して消費
        
        Args:
            state: 検証するstate文字列
            
        Returns:
            bool: 検証が成功したかどうか
        """
        try:
            doc_ref = self.states_collection.document(state)
            doc = doc_ref.get()
            
            if not doc.exists:
                return False
                
            data = doc.to_dict()
            expire_at = data.get('expire_at')
            
            if expire_at and expire_at.replace(tzinfo=None) < datetime.utcnow():
                doc_ref.delete()
                return False
                
            doc_ref.delete()
            return True
        except Exception as e:
            print(f"Error consuming state: {str(e)}")
            return False

================
File: functions/src/slack/app.py
================
from firebase_admin import firestore
from flask import Request, Response
from slack_bolt import App
from slack_bolt.adapter.flask import SlackRequestHandler
import json
import secrets
import os

from src.services.attendance_service import AttendanceService
from src.services.monthly_summary_service import MonthlySummaryService
from src.slack.commands.attendance_commands import AttendanceCommands
from src.slack.commands.summary_commands import SummaryCommands
from src.slack.oauth import setup_oauth_flow
from src.repositories.firestore_repository import FirestoreRepository
from src.config import get_config
from src.slack.events import handle_bot_invited_to_channel, handle_mention_help

def create_slack_bot_function(request: Request) -> Response:
    """Create and return the Slack bot function"""
    try:
        # Get configuration
        config = get_config()
        
        # Initialize Firebase repository
        firebase_repo = FirestoreRepository(
            project_id=config.firebase.project_id,
            credentials_path=config.firebase.credentials_path
        )
        
        # Initialize services
        attendance_service = AttendanceService(firebase_repo)
        monthly_summary_service = MonthlySummaryService(firebase_repo)
        
        # Setup OAuth with Firestore-based stores
        # OAuthSettingsでinstall_path, redirect_uri_path, success_url, failure_urlを指定済み
        oauth_settings = setup_oauth_flow(
            client_id=config.slack.client_id,
            client_secret=config.slack.client_secret,
            db=firestore.client()
        )
        
        # Initialize Slack app with OAuth
        app = App(oauth_settings=oauth_settings)
        
        # Register commands
        AttendanceCommands(app, attendance_service)
        SummaryCommands(app, monthly_summary_service)

        # Register events
        app.event("member_joined_channel")(handle_bot_invited_to_channel)
        app.event("app_mention")(handle_mention_help)
        
        # Initialize handler
        handler = SlackRequestHandler(app)
        
        path = request.path
        method = request.method

        # 成功・失敗時のURLはSlack BoltがOAuth完了後にリダイレクトする。
        # ここでは静的なページを返すのみで、handler.handle()を呼ばない。
        if method == "GET" and path == "/slack/oauth_success":
            # インストール成功後の静的メッセージを表示
            return Response(
                "<html><body><h1>インストールが完了しました！</h1>"
                "<p>このページを閉じ、Slackワークスペースでボットをお使いください。</p></body></html>",
                status=200,
                mimetype='text/html'
            )
        
        if method == "GET" and path == "/slack/oauth_failure":
            error = request.args.get("error", "不明なエラー")
            # インストール失敗時の静的メッセージを表示
            return Response(
                f"<html><body><h1>インストールに失敗しました</h1>"
                f"<p>エラー: {error}</p>"
                f"<p><a href='/slack/install'>再度インストールを試みる</a></p></body></html>",
                status=400,
                mimetype='text/html'
            )

        # それ以外のURL（/slack/install, /slack/oauth_redirect 含む）は
        # handler.handle(request)でSlack Boltに処理を委譲
        # Boltはinstall_path, redirect_uri_pathに対応するGET処理を内部的に行う
        return handler.handle(request)
        
    except Exception as e:
        print(f"Error in create_slack_bot_function: {str(e)}")
        return Response(
            json.dumps({
                "error": "Internal Server Error",
                "message": str(e)
            }),
            status=500,
            mimetype='application/json'
        )

================
File: functions/src/slack/events.py
================
def handle_bot_invited_to_channel(event, client, logger):
    """
    Bot自身がチャンネルに追加された際に、自動で使い方とガイドサイトを案内する。
    Slack APIの `auth.test` で取得した bot_user_id と
    event["user"] のIDが一致したら、ボットが追加されたと判断する。
    """
    try:
        auth_result = client.auth_test()
        bot_user_id = auth_result["user_id"]

        # joined_user が bot_user_id と一致＝Bot自身がチャンネルに招待された
        if event.get("user") == bot_user_id:
            usage_instructions = (
                "こんにちは！チャンネルにBotを追加していただきありがとうございます。\n\n"
                "▼ まずはこちらのガイドサイトもご参照ください：\n"
                "<https://aerial-lentil-c95.notion.site/bot-164d7101a27680d98fbae0385153a637>\n\n"
                "▼ 簡単な使い方はこちら：\n"
                "- `/punch_in`: 出勤\n"
                "- `/punch_out`: 退勤\n"
                "- `/break_begin`: 休憩開始\n"
                "- `/break_end`: 休憩終了\n"
                "- `/summary`: 勤怠サマリー\n\n"
                "ご不明点があればお気軽にメンションしてください！"
            )
            client.chat_postMessage(
                channel=event["channel"],
                text=usage_instructions
            )
    except Exception as e:
        logger.error(f"Error in handle_bot_invited_to_channel: {e}")


def handle_mention_help(event, client, say, logger):
    """
    @bot でメンションされた時に、"help" というキーワードが含まれていれば
    利用可能コマンド一覧と説明書URLを案内する。
    """
    try:
        text = event.get("text", "")
        
        # "help" が含まれていればヘルプを表示
        # (全角/半角大小文字を気にしないように lower() して判定)
        if "help" in text.lower():
            help_message = (
                "▼ 以下のコマンドをご利用いただけます。\n"
                "• `/punch_in`: 出勤\n"
                "• `/punch_out`: 退勤\n"
                "• `/break_begin`: 休憩開始\n"
                "• `/break_end`: 休憩終了\n"
                "• `/summary`: 勤怠サマリー\n\n"
                "こちらのガイドサイトにも詳しい使い方が掲載されています。\n"
                "<https://aerial-lentil-c95.notion.site/bot-164d7101a27680d98fbae0385153a637>\n\n"
                "不明点があればお気軽にお問い合わせください！"
            )
            # say() でメンションがあったチャンネルに返信
            say(text=help_message)
        else:
            # help 以外のメンションには任意の対応が可能
            # とりあえず簡単なメッセージだけ返信
            say(text="ご用件は何でしょうか？\n`@bot help` と呼びかけるとヘルプを表示します。")
    except Exception as e:
        logger.error(f"Error in handle_mention_help: {e}")

================
File: functions/src/slack/message_builder.py
================
from datetime import datetime
from typing import List, Dict, Any

class MessageBuilder:
    @staticmethod
    def format_time(dt: datetime) -> str:
        """時刻を見やすい形式にフォーマット"""
        return dt.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def format_duration(minutes: float) -> str:
        """時間を時間と分の形式にフォーマット"""
        hours = int(minutes // 60)
        mins = int(minutes % 60)
        if hours > 0:
            return f"{hours}時間{mins}分"
        return f"{mins}分"

    @staticmethod
    def create_punch_in_message(username: str, time: datetime) -> List[Dict[str, Any]]:
        """出勤メッセージを作成"""
        return [
            {
                "type": "divider"
            },
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "☀️ 出勤記録",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*従業員:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*出勤時刻:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "今日も一日頑張りましょう！ 👍"
                    }
                ]
            },
            {
                "type": "divider"
            }
        ]

    @staticmethod
    def create_punch_out_message(username: str, time: datetime, working_time: float, total_break_time: float) -> List[Dict[str, Any]]:
        """退勤メッセージを作成"""
        return [
            {
                "type": "divider"
            },
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "🌙 退勤記録",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*従業員:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*退勤時刻:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*実働時間:*\n{MessageBuilder.format_duration(working_time)}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*休憩時間:*\n{MessageBuilder.format_duration(total_break_time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "お疲れ様でした！ 🌟"
                    }
                ]
            },
            {
                "type": "divider"
            }
        ]

    @staticmethod
    def create_break_start_message(username: str, time: datetime) -> List[Dict[str, Any]]:
        """休憩開始メッセージを作成"""
        return [
            {
                "type": "divider"
            },
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "☕️ 休憩開始",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*従業員:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*開始時刻:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "ゆっくり休憩してください 🍵"
                    }
                ]
            },
            {
                "type": "divider"
            }
        ]

    @staticmethod
    def create_break_end_message(username: str, time: datetime, duration: float) -> List[Dict[str, Any]]:
        """休憩終了メッセージを作成"""
        return [
            {
                "type": "divider"
            },
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "🔙 休憩終了",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*従業員:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*終了時刻:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*休憩時間:*\n{MessageBuilder.format_duration(duration)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "それでは、仕事に戻りましょう！ 💪"
                    }
                ]
            },
            {
                "type": "divider"
            }
        ]

    @staticmethod
    def create_error_message(error_message: str) -> List[Dict[str, Any]]:
        """エラーメッセージを作成"""
        return [
            {
                "type": "divider"
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"⚠️ *エラー*: {error_message}"
                }
            },
            {
                "type": "divider"
            }
        ]
    
    @staticmethod
    def create_monthly_summary_message(username: str, summary: Dict[str, Any]) -> List[Dict[str, Any]]:
        """月次サマリーメッセージを作成"""
        blocks = [
            {
                "type": "divider"
            },
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"📊 {summary['year']}年{summary['month']}月の勤怠サマリー",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*従業員:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*月間合計勤務時間:*\n{MessageBuilder.format_duration(summary['total_working_time'])}"
                    }
                ]
            },
            {
                "type": "divider"
            }
        ]

        # 週次サマリーを追加
        weekly_fields = []
        for week, total in summary['weekly_totals'].items():
            weekly_fields.append({
                "type": "mrkdwn",
                "text": f"*第{week}週:*\n{MessageBuilder.format_duration(total)}"
            })

        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": "*週次サマリー*"
            }
        })

        blocks.append({
            "type": "section",
            "fields": weekly_fields
        })

        # CSVダウンロードボタンを追加
        blocks.extend([
            {
                "type": "divider"
            },
            {
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "CSVでダウンロード",
                            "emoji": True
                        },
                        "value": f"{summary['year']}-{summary['month']}",
                        "action_id": "download_csv",
                        "style": "primary"
                    }
                ]
            }
        ])

        return blocks

================
File: functions/src/slack/oauth.py
================
# src/slack/oauth.py

import os
from slack_bolt.oauth.oauth_settings import OAuthSettings
from firebase_admin import firestore
from .store.firestore_installation_store import FirestoreInstallationStore
from .store.firestore_state_store import FirestoreStateStore

def setup_oauth_flow(client_id: str, client_secret: str, db: firestore.Client):
    """OAuthフローの設定を行う"""
    
    # インストール情報と状態管理用のストアを初期化
    installation_store = FirestoreInstallationStore(db)
    state_store = FirestoreStateStore(db)

    # スコープ設定
    # 'bot'スコープを削除し、'files:write:user'を使用
    SCOPES = [
        "chat:write",
        "commands",
        "files:write",
        "users:read",
        "users:read.email"
    ]

    base_url = os.getenv("SLACK_APP_BASE_URL", "https://slack-bot-function-2vwbe2ah2q-uc.a.run.app")
    
    oauth_settings = OAuthSettings(
        client_id=client_id,
        client_secret=client_secret,
        scopes=SCOPES,
        installation_store=installation_store,
        state_store=state_store,
        install_path="/slack/install",
        redirect_uri_path="/slack/oauth_redirect",
        redirect_uri=f"{base_url}/slack/oauth_redirect",
        success_url="/slack/oauth_success",
        failure_url="/slack/oauth_failure"
    )
    
    return oauth_settings

================
File: functions/src/utils/time_utils.py
================
from datetime import datetime, timedelta
import calendar
import pytz

from ..config import get_config

def get_current_time() -> datetime:
    """現在時刻を設定されたタイムゾーンで取得"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    return datetime.now(timezone)

def get_start_of_month(year: int, month: int) -> datetime:
    """月初日の0時0分を取得"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    return datetime(year, month, 1, 0, 0, 0, tzinfo=timezone)

def get_end_of_month(year: int, month: int) -> datetime:
    """月末日の23時59分59秒を取得"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    
    # 月末日を取得
    _, last_day = calendar.monthrange(year, month)
    
    return datetime(year, month, last_day, 23, 59, 59, tzinfo=timezone)

def get_week_number(date: datetime) -> int:
    """日付から週番号を取得（1-5）"""
    return (date.day - 1) // 7 + 1

================
File: functions/src/config.py
================
import os
from pathlib import Path
from typing import Any
from dotenv import load_dotenv

from omegaconf import OmegaConf

_config = None

def init_config() -> Any:
    """設定を初期化"""
    global _config
    
    if _config is not None:
        return _config

    # .envファイルを読み込む
    load_dotenv()
    
    # デフォルトの設定ファイルのパス
    config_path = Path(__file__).parent.parent / "config" / "config.yaml"
    
    # 基本設定の読み込み
    _config = OmegaConf.load(config_path)
    
    # 環境変数で上書き
    env_config = OmegaConf.create({
        "slack": {
            "bot_token": os.getenv("SLACK_BOT_TOKEN"),
            "signing_secret": os.getenv("SLACK_SIGNING_SECRET"),
            "app_token": os.getenv("SLACK_APP_TOKEN"),
            "client_id": os.getenv("SLACK_CLIENT_ID"),
            "client_secret": os.getenv("SLACK_CLIENT_SECRET")
        },
        "firebase": {
            "project_id": os.getenv("APP_FIREBASE_PROJECT_ID"),
            "credentials_path": os.getenv("APP_FIREBASE_CREDENTIALS_PATH"),
        }
    })
    
    _config = OmegaConf.merge(_config, env_config)
    return _config

def get_config() -> Any:
    """設定を取得"""
    global _config
    if _config is None:
        _config = init_config()
    return _config

================
File: functions/src/main.py
================
import asyncio
from flask import Flask, request
import functions_framework
from slack_bolt.adapter.socket_mode.async_handler import AsyncSocketModeHandler

from src.config import init_config
from src.repositories.firestore_repository import FirestoreRepository
from src.services.attendance_service import AttendanceService
from src.services.monthly_summary_service import MonthlySummaryService
from src.slack.app import SlackApp

# Configuration
config = init_config()

print("Initializing services...")

# Initialize repositories
firestore_repo = FirestoreRepository(
    project_id=config.firebase.project_id,
    credentials_path=config.firebase.credentials_path
)

# Initialize services
attendance_service = AttendanceService(firestore_repo)
monthly_summary_service = MonthlySummaryService(firestore_repo)  # 追加

print("Initializing Slack app...")

# Initialize Slack app
slack_app = SlackApp(
    bot_token=config.slack.bot_token,
    signing_secret=config.slack.signing_secret,
    app_token=config.slack.app_token,
    attendance_service=attendance_service,
    monthly_summary_service=monthly_summary_service  # 追加
)

app = Flask(__name__)
handler = slack_app.get_handler()

@functions_framework.http
def slack_bot(request):
    """Cloud Functions用のエントリーポイント"""
    if request.method == "POST":
        # Slackからのリクエストを処理
        return handler.handle(request)
    return "Method not allowed", 405

async def start_socket_mode():
    """Socket Modeハンドラーの起動"""
    try:
        app_handler = AsyncSocketModeHandler(
            app=slack_app.get_app(),
            app_token=config.slack.app_token
        )
        await app_handler.start_async()
    except Exception as e:
        print(f"Error starting socket mode: {e}")
        raise

if __name__ == "__main__":
    print("Starting socket mode...")
    # ローカル開発用
    # Socket Modeの場合
    asyncio.run(start_socket_mode())

================
File: functions/main.py
================
import os
import json
from dotenv import load_dotenv
from firebase_functions import https_fn
from firebase_admin import initialize_app, credentials

from src.slack.app import create_slack_bot_function

# 環境変数の読み込み
load_dotenv()

# Firebase認証情報の設定
try:
    cred_path = os.getenv('APP_FIREBASE_CREDENTIALS_PATH')
    if not cred_path:
        raise ValueError("Firebase credentials path not set in environment variables")
    
    if not os.path.exists(cred_path):
        raise FileNotFoundError(f"Firebase credentials file not found at: {cred_path}")
    
    cred = credentials.Certificate(cred_path)
    initialize_app(cred)
except Exception as e:
    print(f"Firebase initialization error: {str(e)}")
    raise

@https_fn.on_request()
def slack_bot_function(request: https_fn.Request) -> https_fn.Response:
    """
    Slackボットのエントリーポイント関数
    
    Args:
        request: Cloud Functionsのリクエストオブジェクト
        
    Returns:
        Response: Cloud Functionsのレスポンスオブジェクト
    """
    try:
        # 全てのリクエストはcreate_slack_bot_functionで処理
        return create_slack_bot_function(request)
    except Exception as e:
        print(f"Error in slack_bot_function: {str(e)}")
        return https_fn.Response(
            json.dumps({
                "error": "Internal Server Error",
                "message": str(e)
            }),
            status=500,
            mimetype='application/json'
        )

================
File: functions/requirements.txt
================
firebase-functions==0.4.2
firebase-admin>=6.2.0
slack-bolt>=1.18.0
slack-sdk>=3.21.3
omegaconf>=2.3.0
python-dateutil>=2.8.2
pytz>=2023.3
aiohttp>=3.8.5
functions-framework>=3.4.0
flask>=2.3.3
python-dotenv>=1.0.0

================
File: .firebaserc
================
{
  "projects": {
    "default": "slack-attendance-bot-4a3a5"
  },
  "targets": {},
  "etags": {}
}

================
File: .gitignore
================
**.log
**.json
.env
config/firebase-credentials.json
.env
__pycache__
*.pyc
*venv
data/installations/
data/states/
repopack-output.txt

================
File: firestore.rules
================
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // 勤怠記録のルール
    match /attendance/{document} {
      allow read, write: if request.auth != null;
      
      // 月次データ取得のための複数ドキュメント読み取り許可
      allow list: if request.auth != null 
        && request.query.limit <= 1000
        && request.query.orderBy == "start_time";
    }

    // Slackインストール情報のルール
    match /slack_installations/{installationId} {
      // Cloud Functions からのみアクセス可能
      allow read, write: if request.auth.token.firebase.sign_in_provider == 'google.com'
        && request.auth.token.firebase.sign_in_provider == 'service_account';
    }

    // Slackボット情報のルール
    match /slack_bots/{botId} {
      // Cloud Functions からのみアクセス可能
      allow read, write: if request.auth.token.firebase.sign_in_provider == 'google.com'
        && request.auth.token.firebase.sign_in_provider == 'service_account';
    }

    // OAuth状態管理のルール
    match /slack_oauth_states/{stateId} {
      // Cloud Functions からのみアクセス可能
      allow read, write: if request.auth.token.firebase.sign_in_provider == 'google.com'
        && request.auth.token.firebase.sign_in_provider == 'service_account';
    }

    // デフォルトルール
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
