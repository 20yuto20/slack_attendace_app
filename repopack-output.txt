This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-10T01:19:53.400Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
attendance/
  .gitignore
  main.py
  requirements.txt
  schema.py
config/
  check_config.py
  config.yaml
src/
  models/
    attendance.py
  repositories/
    firestore_repository.py
  services/
    attendance_service.py
    monthly_summary_service.py
  slack/
    commands/
      attendance_commands.py
      summary_commands.py
    app.py
    message_builder.py
  utils/
    time_utils.py
  config.py
  main.py
.firebaserc
.gitignore
firestore.rules
requirements.txt
Stracture.md

================================================================
Repository Files
================================================================

================
File: attendance/.gitignore
================
*.local

================
File: attendance/main.py
================
# Welcome to Cloud Functions for Firebase for Python!
# To get started, simply uncomment the below code or create your own.
# Deploy with `firebase deploy`

from firebase_functions import https_fn
from firebase_admin import initialize_app

# initialize_app()
#
#
# @https_fn.on_request()
# def on_request_example(req: https_fn.Request) -> https_fn.Response:
#     return https_fn.Response("Hello world!")

================
File: attendance/requirements.txt
================
firebase_functions~=0.1.0

================
File: attendance/schema.py
================
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List

@dataclass
class Attendance:
    """出勤記録のスキーマ定義"""
    user_id: str
    user_name: str
    start_time: datetime
    end_time: Optional[datetime] = None
    total_break_time: float = 0.0  # 休憩時間の合計（分）

    def to_dict(self) -> dict:
        return {
            "user_id": self.user_id,
            "user_name": self.user_name,
            "start_time": start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "total_break_time": self.total_break_time
        }

@dataclass
class BreakTime:
    """休憩時間のスキーマ定義"""
    attendance_id: str
    start_time: datetime
    end_time: Optional[datetime] = None
    
    def to_dict(self) -> dict:
        return {
            "attendance_id": self.attendance_id,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None
        }

================
File: config/check_config.py
================
#!/usr/bin/env python
# src/cli/check_config.py

import os
import sys
from pathlib import Path
from typing import Dict, List, Tuple
import logging
from dataclasses import dataclass
from colorama import init, Fore, Style
from dotenv import load_dotenv  # dotenvをインポート

# カラー出力の初期化
init()

# .envファイルを読み込む
load_dotenv()  # この行を追加

@dataclass
class ConfigCheckResult:
    name: str
    value: str
    exists: bool
    is_file_exists: bool = None
    
    def get_status_color(self) -> str:
        if self.exists:
            if self.is_file_exists is None:
                return Fore.GREEN
            elif self.is_file_exists:
                return Fore.GREEN
            else:
                return Fore.RED
        return Fore.RED

    def get_status_symbol(self) -> str:
        if self.exists:
            if self.is_file_exists is None:
                return "✓"
            elif self.is_file_exists:
                return "✓"
            else:
                return "×"
        return "×"

def check_env_vars() -> List[ConfigCheckResult]:
    """環境変数をチェックして結果を返す"""
    required_vars = {
        "SLACK_BOT_TOKEN": "Slackボットトークン",
        "SLACK_SIGNING_SECRET": "Slack署名シークレット",
        "SLACK_APP_TOKEN": "Slackアプリトークン",
        "FIREBASE_PROJECT_ID": "Firebaseプロジェクトのプロジェクトid",
        "FIREBASE_CREDENTIALS_PATH": "Firebase認証情報ファイルのパス"
    }
    
    results = []
    
    for var, description in required_vars.items():
        value = os.getenv(var, '')
        exists = bool(value)
        
        # Firebase認証情報ファイルの場合は、ファイルの存在もチェック
        is_file_exists = None
        if var == "FIREBASE_CREDENTIALS_PATH" and exists:
            is_file_exists = Path(value).exists()
        
        results.append(ConfigCheckResult(
            name=var,
            value=value[:20] + '...' if value and len(value) > 20 else value,
            exists=exists,
            is_file_exists=is_file_exists
        ))
    
    return results

def main():
    """メイン処理"""
    try:
        # 現在のパスを表示
        print(f"{Fore.CYAN}現在の作業ディレクトリ:{Style.RESET_ALL} {os.getcwd()}")
        print(f"{Fore.CYAN}.envファイルの場所:{Style.RESET_ALL} {os.path.join(os.getcwd(), '.env')}")
        
        # .envファイルの存在チェックを追加
        env_path = Path(os.getcwd()) / '.env'
        if not env_path.exists():
            print(f"\n{Fore.RED}Warning: .envファイルが見つかりません{Style.RESET_ALL}")
        
        print("\n=== 環境変数チェック ===\n")
        
        results = check_env_vars()
        
        # 結果の表示
        for result in results:
            status_color = result.get_status_color()
            status_symbol = result.get_status_symbol()
            
            print(f"{status_color}{status_symbol}{Style.RESET_ALL} {result.name}: ", end='')
            
            if result.exists:
                print(f"{Fore.CYAN}{result.value}{Style.RESET_ALL}")
                if result.is_file_exists is not None and not result.is_file_exists:
                    print(f"  {Fore.RED}Warning: ファイルが存在しません{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}未設定{Style.RESET_ALL}")
        
        # 成功・失敗の判定
        all_success = all(r.exists and (r.is_file_exists is None or r.is_file_exists) for r in results)
        
        print("\n=== チェック結果 ===")
        if all_success:
            print(f"{Fore.GREEN}✓ すべての設定が正常です{Style.RESET_ALL}")
            sys.exit(0)
        else:
            print(f"{Fore.RED}× 一部の設定に問題があります{Style.RESET_ALL}")
            sys.exit(1)
            
    except Exception as e:
        print(f"{Fore.RED}エラーが発生しました: {str(e)}{Style.RESET_ALL}")
        sys.exit(1)

if __name__ == "__main__":
    main()

================
File: config/config.yaml
================
slack:
  bot_token: "${SLACK_BOT_TOKEN}"
  signing_secret: "${SLACK_SIGNING_SECRET}"
  app_token: "${SLACK_APP_TOKEN}"

firebase:
  project_id: "slack-attendance-bot-4a3a5"
  credentials_path: "config/firebase-credentials.json"

application:
  timezone: "Asia/Tokyo"

================
File: src/models/attendance.py
================
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional

@dataclass
class BreakPeriod:
    start_time: datetime
    end_time: Optional[datetime] = None

    def get_duration(self) -> float:
        """休憩時間を分単位で計算"""
        if not self.end_time:
            return 0.0
        duration = (self.end_time - self.start_time).total_seconds() / 60
        return round(duration, 2)

@dataclass
class Attendance:
    user_id: str
    user_name: str
    start_time: datetime
    end_time: Optional[datetime] = None
    break_periods: List[BreakPeriod] = None

    def __post_init__(self):
        if self.break_periods is None:
            self.break_periods = []

    def get_total_break_time(self) -> float:
        """総休憩時間を分単位で計算"""
        return sum(period.get_duration() for period in self.break_periods)

    def get_working_time(self) -> float:
        """実労働時間を分単位で計算（休憩時間を除く）"""
        if not self.end_time:
            return 0.0
        total_duration = (self.end_time - self.start_time).total_seconds() / 60
        return round(total_duration - self.get_total_break_time(), 2)

    def to_dict(self) -> dict:
        """Firestoreに保存するためのdict形式に変換"""
        return {
            "user_id": self.user_id,
            "user_name": self.user_name,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "break_periods": [
                {
                    "start_time": period.start_time.isoformat(),
                    "end_time": period.end_time.isoformat() if period.end_time else None
                }
                for period in self.break_periods
            ]
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'Attendance':
        """dict形式からAttendanceオブジェクトを生成"""
        break_periods = [
            BreakPeriod(
                start_time=datetime.fromisoformat(period["start_time"]),
                end_time=datetime.fromisoformat(period["end_time"]) if period.get("end_time") else None
            )
            for period in data.get("break_periods", [])
        ]
        return cls(
            user_id=data["user_id"],
            user_name=data["user_name"],
            start_time=datetime.fromisoformat(data["start_time"]),
            end_time=datetime.fromisoformat(data["end_time"]) if data.get("end_time") else None,
            break_periods=break_periods
        )

================
File: src/repositories/firestore_repository.py
================
import firebase_admin
from firebase_admin import credentials, firestore
from datetime import datetime
from typing import Optional, List, Dict, Any
from google.cloud.firestore_v1.base_query import FieldFilter, And, Or

from src.models.attendance import Attendance  # 絶対パスに修正
from src.utils.time_utils import get_current_time

class FirestoreRepository:
    def __init__(self, project_id: str, credentials_path: str):
        cred = credentials.Certificate(credentials_path)
        firebase_admin.initialize_app(cred, {
            'projectId': project_id,
        })
        self.db = firestore.client()
        self.attendance_collection = self.db.collection('attendance')

    def create_attendance(self, attendance: Attendance) -> None:
        """新しい勤怠記録を作成"""
        doc_ref = self.attendance_collection.document()
        doc_ref.set(attendance.to_dict())

    def get_active_attendance(self, user_id: str) -> Optional[Attendance]:
        """ユーザーのアクティブな（終了していない）勤怠記録を取得"""
        query = (
            self.attendance_collection
            .where(filter=firestore.FieldFilter("user_id", "==", user_id))
            .where(filter=firestore.FieldFilter("end_time", "==", None))
            .limit(1)
        )
        docs = query.get()
        
        for doc in docs:
            return Attendance.from_dict(doc.to_dict())
        return None

    def update_attendance(self, attendance: Attendance) -> None:
        """勤怠記録を更新"""
        query = (
            self.attendance_collection
            .where(filter=firestore.FieldFilter("user_id", "==", attendance.user_id))
            .where(filter=firestore.FieldFilter("end_time", "==", None))
            .limit(1)
        )
        docs = query.get()
        
        for doc in docs:
            doc.reference.set(attendance.to_dict())
            break

    def get_attendance_by_period(
        self, 
        user_id: str, 
        start_date: datetime, 
        end_date: datetime,
        batch_size: int = 100
    ) -> List[Attendance]:
        """
        指定期間の勤怠記録を取得
        
        Args:
            user_id (str): ユーザーID
            start_date (datetime): 期間開始日時
            end_date (datetime): 期間終了日時
            batch_size (int): 1回のクエリで取得するドキュメント数
            
        Returns:
            List[Attendance]: 勤怠記録のリスト
        
        Raises:
            FirebaseError: Firestoreへのアクセスに失敗した場合
        """
        try:
            # クエリの構築
            query = (
                self.attendance_collection
                .where(filter=FieldFilter("user_id", "==", user_id))
                .where(filter=FieldFilter("start_time", ">=", start_date.isoformat()))
                .where(filter=FieldFilter("start_time", "<=", end_date.isoformat()))
                .order_by("start_time")
                .limit(batch_size)
            )
            
            records = []
            docs = query.get()
            
            # バッチ処理でデータを取得
            while docs:
                records.extend([self._convert_to_attendance(doc) for doc in docs])
                
                # 次のバッチがあるか確認
                last_doc = docs[-1]
                docs = (
                    query
                    .start_after(last_doc)
                    .get()
                )
            
            return records
            
        except Exception as e:
            print(f"Error retrieving attendance records: {str(e)}")
            raise

    def _convert_to_attendance(self, doc: firestore.DocumentSnapshot) -> Attendance:
        """
        Firestoreのドキュメントを勤怠オブジェクトに変換
        
        Args:
            doc (DocumentSnapshot): Firestoreのドキュメント
            
        Returns:
            Attendance: 変換された勤怠オブジェクト
        """
        data = doc.to_dict()
        return Attendance.from_dict(data)

    def get_attendance_stats(
        self, 
        user_id: str, 
        start_date: datetime, 
        end_date: datetime
    ) -> Dict[str, Any]:
        """
        指定期間の勤怠統計を取得
        
        Args:
            user_id (str): ユーザーID
            start_date (datetime): 期間開始日時
            end_date (datetime): 期間終了日時
            
        Returns:
            Dict[str, Any]: 統計情報
        """
        records = self.get_attendance_by_period(user_id, start_date, end_date)
        
        total_working_time = 0
        total_break_time = 0
        daily_stats = {}
        
        for record in records:
            date_key = record.start_time.date().isoformat()
            
            if date_key not in daily_stats:
                daily_stats[date_key] = {
                    'working_time': 0,
                    'break_time': 0,
                    'attendance_count': 0
                }
            
            daily_stats[date_key]['working_time'] += record.get_working_time()
            daily_stats[date_key]['break_time'] += record.get_total_break_time()
            daily_stats[date_key]['attendance_count'] += 1
            
            total_working_time += record.get_working_time()
            total_break_time += record.get_total_break_time()
        
        return {
            'total_working_time': total_working_time,
            'total_break_time': total_break_time,
            'daily_stats': daily_stats,
            'record_count': len(records)
        }

================
File: src/services/attendance_service.py
================
from datetime import datetime
from typing import Optional, Tuple

from src.models.attendance import Attendance, BreakPeriod
from src.repositories.firestore_repository import FirestoreRepository
from src.utils.time_utils import get_current_time

class AttendanceService:
    def __init__(self, repository: FirestoreRepository):
        self.repository = repository

    def punch_in(self, user_id: str, user_name: str) -> Tuple[bool, str, Optional[datetime]]:
        """出勤処理"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if active_attendance:
            return False, "既に出勤済みです。", None

        current_time = get_current_time()
        attendance = Attendance(
            user_id=user_id,
            user_name=user_name,
            start_time=current_time
        )
        self.repository.create_attendance(attendance)
        return True, "出勤を記録しました。", current_time

    def punch_out(self, user_id: str) -> Tuple[bool, str, Optional[Attendance]]:
        """退勤処理"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "出勤記録が見つかりません。", None

        if active_attendance.break_periods and not active_attendance.break_periods[-1].end_time:
            return False, "休憩中は退勤できません。まず休憩を終了してください。", None

        active_attendance.end_time = get_current_time()
        self.repository.update_attendance(active_attendance)
        return True, "退勤を記録しました。", active_attendance

    def start_break(self, user_id: str) -> Tuple[bool, str, Optional[datetime]]:
        """休憩開始処理"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "出勤記録が見つかりません。", None

        if active_attendance.break_periods and not active_attendance.break_periods[-1].end_time:
            return False, "既に休憩中です。", None

        current_time = get_current_time()
        active_attendance.break_periods.append(BreakPeriod(start_time=current_time))
        self.repository.update_attendance(active_attendance)
        return True, "休憩を開始しました。", current_time

    def end_break(self, user_id: str) -> Tuple[bool, str, Optional[Tuple[datetime, float]]]:
        """休憩終了処理"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "出勤記録が見つかりません。", None

        if not active_attendance.break_periods or active_attendance.break_periods[-1].end_time:
            return False, "休憩が開始されていません。", None

        current_time = get_current_time()
        active_attendance.break_periods[-1].end_time = current_time
        break_duration = active_attendance.break_periods[-1].get_duration()
        
        self.repository.update_attendance(active_attendance)
        return True, "休憩を終了しました。", (current_time, break_duration)

================
File: src/services/monthly_summary_service.py
================
from datetime import datetime, timedelta
import calendar
import csv
from io import StringIO
from typing import List, Dict, Any, Tuple

from ..models.attendance import Attendance
from ..repositories.firestore_repository import FirestoreRepository
from ..utils.time_utils import get_current_time, get_start_of_month, get_end_of_month

class MonthlySummaryService:
    def __init__(self, repository: FirestoreRepository):
        self.repository = repository

    def get_monthly_summary(self, user_id: str, year: int, month: int) -> Dict[str, Any]:
        """指定された月の勤怠サマリーを取得"""
        # 月の開始日と終了日を取得
        start_date = get_start_of_month(year, month)
        end_date = get_end_of_month(year, month)
        
        # 指定月の全ての勤怠記録を取得
        records = self.repository.get_attendance_by_period(user_id, start_date, end_date)
        
        # 日ごとの勤怠記録を集計
        daily_records = {}
        weekly_totals = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}  # 週ごとの合計時間
        total_working_time = 0
        
        for record in records:
            date = record.start_time.date()
            week_number = (date.day - 1) // 7 + 1
            
            if date not in daily_records:
                daily_records[date] = {
                    'working_time': 0,
                    'break_time': 0,
                    'week_number': week_number
                }
            
            working_time = record.get_working_time()
            break_time = record.get_total_break_time()
            
            daily_records[date]['working_time'] += working_time
            daily_records[date]['break_time'] += break_time
            weekly_totals[week_number] += working_time
            total_working_time += working_time

        return {
            'daily_records': daily_records,
            'weekly_totals': weekly_totals,
            'total_working_time': total_working_time,
            'year': year,
            'month': month
        }

    def generate_csv(self, user_id: str, user_name: str, year: int, month: int) -> Tuple[str, str]:
        """月次サマリーのCSVを生成"""
        summary = self.get_monthly_summary(user_id, year, month)
        
        # CSVファイル名を生成
        filename = f"attendance_summary_{user_name}_{year}_{month:02d}.csv"
        
        # CSVデータを生成
        output = StringIO()
        writer = csv.writer(output)
        
        # ヘッダー行を書き込み
        writer.writerow(['従業員名', user_name])
        writer.writerow(['年月', f'{year}年{month}月'])
        writer.writerow([])
        writer.writerow(['日付', '曜日', '勤務時間', '休憩時間', '週番号'])
        
        # 日々のデータを書き込み
        daily_records = summary['daily_records']
        for date in sorted(daily_records.keys()):
            record = daily_records[date]
            writer.writerow([
                date.strftime('%Y-%m-%d'),
                date.strftime('%A'),
                f"{record['working_time']:.2f}",
                f"{record['break_time']:.2f}",
                record['week_number']
            ])
        
        # 週次サマリーを書き込み
        writer.writerow([])
        writer.writerow(['週次サマリー'])
        for week, total in summary['weekly_totals'].items():
            writer.writerow([f'第{week}週', f'{total:.2f}'])
        
        # 月次合計を書き込み
        writer.writerow([])
        writer.writerow(['月間合計勤務時間', f"{summary['total_working_time']:.2f}"])
        
        return filename, output.getvalue()

================
File: src/slack/commands/attendance_commands.py
================
from typing import Callable
from slack_bolt import App

from src.services.attendance_service import AttendanceService
from src.slack.message_builder import MessageBuilder

class AttendanceCommands:
    def __init__(self, app: App, attendance_service: AttendanceService):
        self.app = app
        self.attendance_service = attendance_service
        self._register_commands()

    def _register_commands(self) -> None:
        """すべてのコマンドを登録"""
        self._register_command("/punch_in", self._handle_punch_in)
        self._register_command("/punch_out", self._handle_punch_out)
        self._register_command("/break_begin", self._handle_break_begin)
        self._register_command("/break_end", self._handle_break_end)

    def _register_command(self, command: str, handler: Callable) -> None:
        """個別のコマンドを登録"""
        self.app.command(command)(handler)

    async def _handle_punch_in(self, ack, command, say):
        """出勤コマンドの処理"""
        await ack()
        
        success, message, time = self.attendance_service.punch_in(
            user_id=command["user_id"],
            user_name=command["user_name"]
        )

        if success:
            blocks = MessageBuilder.create_punch_in_message(
                username=command["user_name"],
                time=time
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        # チャンネル全体に表示
        await say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    async def _handle_punch_out(self, ack, command, say):
        """退勤コマンドの処理"""
        await ack()
        
        success, message, attendance = self.attendance_service.punch_out(
            user_id=command["user_id"]
        )

        if success:
            blocks = MessageBuilder.create_punch_out_message(
                username=command["user_name"],
                time=attendance.end_time,
                working_time=attendance.get_working_time(),
                total_break_time=attendance.get_total_break_time()
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        # チャンネル全体に表示
        await say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    async def _handle_break_begin(self, ack, command, say):
        """休憩開始コマンドの処理"""
        await ack()
        
        success, message, time = self.attendance_service.start_break(
            user_id=command["user_id"]
        )

        if success:
            blocks = MessageBuilder.create_break_start_message(
                username=command["user_name"],
                time=time
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        # チャンネル全体に表示
        await say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    async def _handle_break_end(self, ack, command, say):
        """休憩終了コマンドの処理"""
        await ack()
        
        success, message, result = self.attendance_service.end_break(
            user_id=command["user_id"]
        )

        if success:
            time, duration = result
            blocks = MessageBuilder.create_break_end_message(
                username=command["user_name"],
                time=time,
                duration=duration
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        # チャンネル全体に表示
        await say(
            blocks=blocks,
            channel=command["channel_id"]
        )

================
File: src/slack/commands/summary_commands.py
================
from datetime import datetime
from typing import Dict, Any, List

from slack_bolt import App
from slack_bolt.async_app import AsyncApp

from ...services.monthly_summary_service import MonthlySummaryService
from ..message_builder import MessageBuilder

class SummaryCommands:
    def __init__(self, app: AsyncApp, summary_service: MonthlySummaryService):
        self.app = app
        self.summary_service = summary_service
        self._register_commands()

    def _register_commands(self) -> None:
        """すべてのコマンドを登録"""
        self.app.command("/summary")(self._handle_summary)
        self.app.action("select_month")(self._handle_month_selection)
        self.app.action("download_csv")(self._handle_csv_download)

    async def _handle_summary(self, ack, body, say):
        """サマリーコマンドの処理"""
        await ack()
        
        current_date = datetime.now()
        blocks = self._create_month_selector_blocks(current_date.year)
        
        await say(
            blocks=blocks,
            channel=body["channel_id"]
        )

    async def _handle_month_selection(self, ack, body, say):
        """月選択の処理"""
        await ack()
        
        selected_value = body["actions"][0]["selected_option"]["value"]
        year, month = map(int, selected_value.split("-"))
        
        summary = self.summary_service.get_monthly_summary(
            user_id=body["user"]["id"],
            year=year,
            month=month
        )
        
        blocks = MessageBuilder.create_monthly_summary_message(
            username=body["user"]["name"],
            summary=summary
        )
        
        await say(
            blocks=blocks,
            channel=body["channel"]["id"]
        )

    async def _handle_csv_download(self, ack, body, client):
        """CSVダウンロードの処理"""
        await ack()
    
        # 選択された年月を取得
        year_month = body["actions"][0]["value"]
        year, month = map(int, year_month.split("-"))
    
        # CSVを生成
        filename, csv_content = self.summary_service.generate_csv(
            user_id=body["user"]["id"],
            user_name=body["user"]["name"],
            year=year,
            month=month
        )
    
        try:
            # files_upload_v2を使用してファイルをアップロード
            response = await client.files_upload_v2(
                channel=body["channel"]["id"],
                filename=filename,
                content=csv_content,
                title=f"{year}年{month}月の勤怠記録",
                initial_comment=f"{year}年{month}月の勤怠記録をCSVでダウンロードしました。"
            )
        
            if not response["ok"]:
                # エラーメッセージを表示
                await client.chat_postMessage(
                    channel=body["channel"]["id"],
                    text=f"CSVファイルのアップロードに失敗しました：{response.get('error', '不明なエラー')}"
                )
        except Exception as e:
            # エラーメッセージを表示
            await client.chat_postMessage(
                channel=body["channel"]["id"],
                text=f"CSVファイルのアップロードに失敗しました：{str(e)}"
            )

    def _create_month_selector_blocks(self, year: int) -> List[Dict[str, Any]]:
        """月選択用のブロックを作成"""
        months = []
        for month in range(1, 13):
            months.append({
                "text": {
                    "type": "plain_text",
                    "text": f"{year}年{month}月"
                },
                "value": f"{year}-{month}"
            })

        return [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "📊 *勤怠サマリー*\n確認したい月を選択してください。"
                }
            },
            {
                "type": "actions",
                "elements": [
                    {
                        "type": "static_select",
                        "placeholder": {
                            "type": "plain_text",
                            "text": "月を選択",
                            "emoji": True
                        },
                        "options": months,
                        "action_id": "select_month"
                    }
                ]
            }
        ]

================
File: src/slack/app.py
================
from slack_bolt.async_app import AsyncApp
from slack_bolt.adapter.flask import SlackRequestHandler

from src.services.attendance_service import AttendanceService
from src.services.monthly_summary_service import MonthlySummaryService  # 追加
from src.slack.commands.attendance_commands import AttendanceCommands
from src.slack.commands.summary_commands import SummaryCommands  # 追加

class SlackApp:
    def __init__(
        self,
        bot_token: str,
        signing_secret: str,
        app_token: str,
        attendance_service: AttendanceService,
        monthly_summary_service: MonthlySummaryService
    ):
        self.app = AsyncApp(
            token=bot_token,
            signing_secret=signing_secret
        )
        self.handler = SlackRequestHandler(self.app)
        self.app_token = app_token
        
        # コマンドの登録
        AttendanceCommands(self.app, attendance_service)
        SummaryCommands(self.app, monthly_summary_service)

    def get_handler(self) -> SlackRequestHandler:
        return self.handler

    def get_app(self) -> AsyncApp:
        return self.app

================
File: src/slack/message_builder.py
================
from datetime import datetime
from typing import List, Dict, Any

class MessageBuilder:
    @staticmethod
    def format_time(dt: datetime) -> str:
        """時刻を見やすい形式にフォーマット"""
        return dt.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def format_duration(minutes: float) -> str:
        """時間を時間と分の形式にフォーマット"""
        hours = int(minutes // 60)
        mins = int(minutes % 60)
        if hours > 0:
            return f"{hours}時間{mins}分"
        return f"{mins}分"

    @staticmethod
    def create_punch_in_message(username: str, time: datetime) -> List[Dict[str, Any]]:
        """出勤メッセージを作成"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "🏃 出勤記録",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*従業員:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*出勤時刻:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "今日も一日頑張りましょう！ 👍"
                    }
                ]
            }
        ]

    @staticmethod
    def create_punch_out_message(username: str, time: datetime, working_time: float, total_break_time: float) -> List[Dict[str, Any]]:
        """退勤メッセージを作成"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "🏃‍♂️ 退勤記録",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*従業員:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*退勤時刻:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*実働時間:*\n{MessageBuilder.format_duration(working_time)}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*休憩時間:*\n{MessageBuilder.format_duration(total_break_time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "お疲れ様でした！ 🌟"
                    }
                ]
            }
        ]

    @staticmethod
    def create_break_start_message(username: str, time: datetime) -> List[Dict[str, Any]]:
        """休憩開始メッセージを作成"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "☕️ 休憩開始",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*従業員:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*開始時刻:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "ゆっくり休憩してください 🍵"
                    }
                ]
            }
        ]

    @staticmethod
    def create_break_end_message(username: str, time: datetime, duration: float) -> List[Dict[str, Any]]:
        """休憩終了メッセージを作成"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "⏰ 休憩終了",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*従業員:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*終了時刻:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*休憩時間:*\n{MessageBuilder.format_duration(duration)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "それでは、仕事に戻りましょう！ 💪"
                    }
                ]
            }
        ]

    @staticmethod
    def create_error_message(error_message: str) -> List[Dict[str, Any]]:
        """エラーメッセージを作成"""
        return [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"⚠️ *エラー*: {error_message}"
                }
            }
        ]
    
    @staticmethod
    def create_monthly_summary_message(username: str, summary: Dict[str, Any]) -> List[Dict[str, Any]]:
        """月次サマリーメッセージを作成"""
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"📊 {summary['year']}年{summary['month']}月の勤怠サマリー",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*従業員:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*月間合計勤務時間:*\n{MessageBuilder.format_duration(summary['total_working_time'])}"
                    }
                ]
            },
            {
                "type": "divider"
            }
        ]

        # 週次サマリーを追加
        weekly_fields = []
        for week, total in summary['weekly_totals'].items():
            weekly_fields.append({
                "type": "mrkdwn",
                "text": f"*第{week}週:*\n{MessageBuilder.format_duration(total)}"
            })

        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": "*週次サマリー*"
            }
        })

        blocks.append({
            "type": "section",
            "fields": weekly_fields
        })

        # CSVダウンロードボタンを追加
        blocks.extend([
            {
                "type": "divider"
            },
            {
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "CSVでダウンロード",
                            "emoji": True
                        },
                        "value": f"{summary['year']}-{summary['month']}",
                        "action_id": "download_csv",
                        "style": "primary"
                    }
                ]
            }
        ])

        return blocks

================
File: src/utils/time_utils.py
================
from datetime import datetime, timedelta
import calendar
import pytz

from ..config import get_config

def get_current_time() -> datetime:
    """現在時刻を設定されたタイムゾーンで取得"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    return datetime.now(timezone)

def get_start_of_month(year: int, month: int) -> datetime:
    """月初日の0時0分を取得"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    return datetime(year, month, 1, 0, 0, 0, tzinfo=timezone)

def get_end_of_month(year: int, month: int) -> datetime:
    """月末日の23時59分59秒を取得"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    
    # 月末日を取得
    _, last_day = calendar.monthrange(year, month)
    
    return datetime(year, month, last_day, 23, 59, 59, tzinfo=timezone)

def get_week_number(date: datetime) -> int:
    """日付から週番号を取得（1-5）"""
    return (date.day - 1) // 7 + 1

================
File: src/config.py
================
import os
from pathlib import Path
from typing import Any
from dotenv import load_dotenv

from omegaconf import OmegaConf

_config = None

def init_config() -> Any:
    """設定を初期化"""
    global _config
    
    if _config is not None:
        return _config

    # .envファイルを読み込む
    load_dotenv()
    
    # デフォルトの設定ファイルのパス
    config_path = Path(__file__).parent.parent / "config" / "config.yaml"
    
    # 基本設定の読み込み
    _config = OmegaConf.load(config_path)
    
    # 環境変数で上書き
    env_config = OmegaConf.create({
        "slack": {
            "bot_token": os.getenv("SLACK_BOT_TOKEN"),
            "signing_secret": os.getenv("SLACK_SIGNING_SECRET"),
            "app_token": os.getenv("SLACK_APP_TOKEN"),
        },
        "firebase": {
            "project_id": os.getenv("FIREBASE_PROJECT_ID"),
            "credentials_path": os.getenv("FIREBASE_CREDENTIALS_PATH"),
        }
    })
    
    _config = OmegaConf.merge(_config, env_config)
    return _config

def get_config() -> Any:
    """設定を取得"""
    global _config
    if _config is None:
        _config = init_config()
    return _config

================
File: src/main.py
================
import asyncio
from flask import Flask, request
import functions_framework
from slack_bolt.adapter.socket_mode.async_handler import AsyncSocketModeHandler

from src.config import init_config
from src.repositories.firestore_repository import FirestoreRepository
from src.services.attendance_service import AttendanceService
from src.services.monthly_summary_service import MonthlySummaryService
from src.slack.app import SlackApp

# Configuration
config = init_config()

print("Initializing services...")

# Initialize repositories
firestore_repo = FirestoreRepository(
    project_id=config.firebase.project_id,
    credentials_path=config.firebase.credentials_path
)

# Initialize services
attendance_service = AttendanceService(firestore_repo)
monthly_summary_service = MonthlySummaryService(firestore_repo)  # 追加

print("Initializing Slack app...")

# Initialize Slack app
slack_app = SlackApp(
    bot_token=config.slack.bot_token,
    signing_secret=config.slack.signing_secret,
    app_token=config.slack.app_token,
    attendance_service=attendance_service,
    monthly_summary_service=monthly_summary_service  # 追加
)

app = Flask(__name__)
handler = slack_app.get_handler()

@functions_framework.http
def slack_bot(request):
    """Cloud Functions用のエントリーポイント"""
    if request.method == "POST":
        # Slackからのリクエストを処理
        return handler.handle(request)
    return "Method not allowed", 405

async def start_socket_mode():
    """Socket Modeハンドラーの起動"""
    try:
        app_handler = AsyncSocketModeHandler(
            app=slack_app.get_app(),
            app_token=config.slack.app_token
        )
        await app_handler.start_async()
    except Exception as e:
        print(f"Error starting socket mode: {e}")
        raise

if __name__ == "__main__":
    print("Starting socket mode...")
    # ローカル開発用
    # Socket Modeの場合
    asyncio.run(start_socket_mode())

================
File: .firebaserc
================
{
  "projects": {
    "default": "slack-attendance-bot-4a3a5"
  },
  "targets": {},
  "etags": {}
}

================
File: .gitignore
================
**.log
**.json
.env
config/firebase-credentials.json
.env
__pycache__
*.pyc

================
File: firestore.rules
================
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // attendance コレクションのルール
    match /attendance/{document} {
      // 認証されたユーザーのみ読み書き可能
      allow read, write: if request.auth != null;
      
      // 月次データ取得のための複数ドキュメント読み取り許可
      // start_timeに基づくクエリを許可
      allow list: if request.auth != null 
        && request.query.limit <= 1000  // 1000件までの制限
        && request.query.orderBy == "start_time";  // start_timeでの並び替えを許可
    }

    // デフォルトルール - 明示的に許可されていないアクセスを拒否
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

================
File: requirements.txt
================
slack-bolt>=1.18.0
slack-sdk>=3.21.3
firebase-admin>=6.2.0
omegaconf>=2.3.0
python-dateutil>=2.8.2
pytz>=2023.3
aiohttp>=3.8.5
functions-framework>=3.4.0
flask>=2.3.3
python-dotenv>=1.0.0

================
File: Stracture.md
================
```
attendance-slack-bot/
├── config/
│   └── config.yaml
├── src/
│   ├── __init__.py
│   ├── main.py
│   ├── constants/
│   │   └── __init__.py
│   ├── models/
│   │   ├── __init__.py
│   │   └── attendance.py
│   ├── repositories/
│   │   ├── __init__.py
│   │   └── firestore_repository.py
│   ├── services/
│   │   ├── __init__.py
│   │   └── attendance_service.py
│   ├── slack/
│   │   ├── __init__.py
│   │   ├── app.py
│   │   ├── commands/
│   │   │   ├── __init__.py
│   │   │   └── attendance_commands.py
│   │   └── message_builder.py
│   └── utils/
│       ├── __init__.py
│       └── time_utils.py
├── requirements.txt
└── README.md
```
