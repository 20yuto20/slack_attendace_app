This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-22T06:55:28.736Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
functions/
  attendance/
    .gitignore
    main.py
    requirements.txt
    schema.py
  config/
    check_config.py
    config.yaml
  src/
    models/
      attendance.py
    repositories/
      firestore_repository.py
    services/
      attendance_service.py
      monthly_summary_service.py
    slack/
      commands/
        attendance_commands.py
        summary_commands.py
      store/
        firestore_installation_store.py
        firestore_state_store.py
      app.py
      message_builder.py
      oauth.py
    utils/
      time_utils.py
    config.py
    main.py
  main.py
  requirements.txt
.firebaserc
.gitignore
firestore.rules

================================================================
Repository Files
================================================================

================
File: functions/attendance/.gitignore
================
*.local

================
File: functions/attendance/main.py
================
# Welcome to Cloud Functions for Firebase for Python!
# To get started, simply uncomment the below code or create your own.
# Deploy with `firebase deploy`

from firebase_functions import https_fn
from firebase_admin import initialize_app

# ()
#
#
# @https_fn.on_request()
# def on_request_example(req: https_fn.Request) -> https_fn.Response:
#     return https_fn.Response("Hello world!")

================
File: functions/attendance/requirements.txt
================
firebase_functions~=0.1.0

================
File: functions/attendance/schema.py
================
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List

@dataclass
class Attendance:
    """å‡ºå‹¤è¨˜éŒ²ã®ã‚¹ã‚­ãƒ¼ãƒå®šç¾©"""
    user_id: str
    user_name: str
    start_time: datetime
    end_time: Optional[datetime] = None
    total_break_time: float = 0.0  # ä¼‘æ†©æ™‚é–“ã®åˆè¨ˆï¼ˆåˆ†ï¼‰

    def to_dict(self) -> dict:
        return {
            "user_id": self.user_id,
            "user_name": self.user_name,
            "start_time": start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "total_break_time": self.total_break_time
        }

@dataclass
class BreakTime:
    """ä¼‘æ†©æ™‚é–“ã®ã‚¹ã‚­ãƒ¼ãƒå®šç¾©"""
    attendance_id: str
    start_time: datetime
    end_time: Optional[datetime] = None
    
    def to_dict(self) -> dict:
        return {
            "attendance_id": self.attendance_id,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None
        }

================
File: functions/config/check_config.py
================
#!/usr/bin/env python

import os
import sys
from pathlib import Path
from typing import List
from dataclasses import dataclass
from colorama import init, Fore, Style
from dotenv import load_dotenv

# ã‚«ãƒ©ãƒ¼å‡ºåŠ›ã®åˆæœŸåŒ–
init()

@dataclass
class ConfigCheckResult:
    name: str
    value: str
    exists: bool
    is_file_exists: bool = None
    
    def get_status_color(self) -> str:
        if self.exists:
            if self.is_file_exists is None or self.is_file_exists:
                return Fore.GREEN
            return Fore.RED
        return Fore.RED

    def get_status_symbol(self) -> str:
        if self.exists:
            if self.is_file_exists is None or self.is_file_exists:
                return "âœ“"
            return "Ã—"
        return "Ã—"

def check_env_vars() -> List[ConfigCheckResult]:
    """ç’°å¢ƒå¤‰æ•°ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦çµæœã‚’è¿”ã™"""
    required_vars = {
        "SLACK_BOT_TOKEN": "Slackãƒœãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³",
        "SLACK_SIGNING_SECRET": "Slackç½²åã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ",
        "SLACK_CLIENT_ID": "Slackã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆID",
        "SLACK_CLIENT_SECRET": "Slackã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ",
        "APP_FIREBASE_PROJECT_ID": "Firebaseãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆid",
        "APP_FIREBASE_CREDENTIALS_PATH": "Firebaseèªè¨¼æƒ…å ±ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹"
    }
    
    results = []
    
    for var, description in required_vars.items():
        value = os.getenv(var, '')
        exists = bool(value)
        
        # Firebaseèªè¨¼æƒ…å ±ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ã‚‚ãƒã‚§ãƒƒã‚¯
        is_file_exists = None
        if var == "APP_FIREBASE_CREDENTIALS_PATH" and exists:
            is_file_exists = Path(value).exists()
        
        results.append(ConfigCheckResult(
            name=var,
            value=value[:20] + '...' if value and len(value) > 20 else value,
            exists=exists,
            is_file_exists=is_file_exists
        ))
    
    return results

def main():
    """ãƒ¡ã‚¤ãƒ³å‡¦ç†"""
    try:
        # .envãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        load_dotenv()
        
        print("\n=== ç’°å¢ƒå¤‰æ•°ãƒã‚§ãƒƒã‚¯ ===\n")
        
        results = check_env_vars()
        
        # çµæœã®è¡¨ç¤º
        for result in results:
            status_color = result.get_status_color()
            status_symbol = result.get_status_symbol()
            
            print(f"{status_color}{status_symbol}{Style.RESET_ALL} {result.name}: ", end='')
            
            if result.exists:
                print(f"{Fore.CYAN}{result.value}{Style.RESET_ALL}")
                if result.is_file_exists is not None and not result.is_file_exists:
                    print(f"  {Fore.RED}Warning: ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}æœªè¨­å®š{Style.RESET_ALL}")
        
        # æˆåŠŸãƒ»å¤±æ•—ã®åˆ¤å®š
        all_success = all(r.exists and (r.is_file_exists is None or r.is_file_exists) for r in results)
        
        print("\n=== ãƒã‚§ãƒƒã‚¯çµæœ ===")
        if all_success:
            print(f"{Fore.GREEN}âœ“ ã™ã¹ã¦ã®è¨­å®šãŒæ­£å¸¸ã§ã™{Style.RESET_ALL}")
            sys.exit(0)
        else:
            print(f"{Fore.RED}Ã— ä¸€éƒ¨ã®è¨­å®šã«å•é¡ŒãŒã‚ã‚Šã¾ã™{Style.RESET_ALL}")
            sys.exit(1)
            
    except Exception as e:
        print(f"{Fore.RED}ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}{Style.RESET_ALL}")
        sys.exit(1)

if __name__ == "__main__":
    main()

================
File: functions/config/config.yaml
================
slack:
  bot_token: "${SLACK_BOT_TOKEN}"
  signing_secret: "${SLACK_SIGNING_SECRET}"
  app_token: "${SLACK_APP_TOKEN}"
  client_id: "${SLACK_CLIENT_ID}"
  client_secret: "${SLACK_CLIENT_SECRET}"
  

firebase:
  project_id: "slack-attendance-bot-4a3a5"
  credentials_path: "config/firebase-credentials.json"

application:
  timezone: "Asia/Tokyo"

================
File: functions/src/models/attendance.py
================
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional

@dataclass
class BreakPeriod:
    start_time: datetime
    end_time: Optional[datetime] = None

    def get_duration(self) -> float:
        """ä¼‘æ†©æ™‚é–“ã‚’åˆ†å˜ä½ã§è¨ˆç®—"""
        if not self.end_time:
            return 0.0
        duration = (self.end_time - self.start_time).total_seconds() / 60
        return round(duration, 2)

@dataclass
class Attendance:
    user_id: str
    user_name: str
    start_time: datetime
    end_time: Optional[datetime] = None
    break_periods: List[BreakPeriod] = None

    def __post_init__(self):
        if self.break_periods is None:
            self.break_periods = []

    def get_total_break_time(self) -> float:
        """ç·ä¼‘æ†©æ™‚é–“ã‚’åˆ†å˜ä½ã§è¨ˆç®—"""
        return sum(period.get_duration() for period in self.break_periods)

    def get_working_time(self) -> float:
        """å®ŸåŠ´åƒæ™‚é–“ã‚’åˆ†å˜ä½ã§è¨ˆç®—ï¼ˆä¼‘æ†©æ™‚é–“ã‚’é™¤ãï¼‰"""
        if not self.end_time:
            return 0.0
        total_duration = (self.end_time - self.start_time).total_seconds() / 60
        return round(total_duration - self.get_total_break_time(), 2)

    def to_dict(self) -> dict:
        """Firestoreã«ä¿å­˜ã™ã‚‹ãŸã‚ã®dictå½¢å¼ã«å¤‰æ›"""
        return {
            "user_id": self.user_id,
            "user_name": self.user_name,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "break_periods": [
                {
                    "start_time": period.start_time.isoformat(),
                    "end_time": period.end_time.isoformat() if period.end_time else None
                }
                for period in self.break_periods
            ]
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'Attendance':
        """dictå½¢å¼ã‹ã‚‰Attendanceã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆ"""
        break_periods = [
            BreakPeriod(
                start_time=datetime.fromisoformat(period["start_time"]),
                end_time=datetime.fromisoformat(period["end_time"]) if period.get("end_time") else None
            )
            for period in data.get("break_periods", [])
        ]
        return cls(
            user_id=data["user_id"],
            user_name=data["user_name"],
            start_time=datetime.fromisoformat(data["start_time"]),
            end_time=datetime.fromisoformat(data["end_time"]) if data.get("end_time") else None,
            break_periods=break_periods
        )

================
File: functions/src/repositories/firestore_repository.py
================
import firebase_admin
from firebase_admin import credentials, firestore
from datetime import datetime
from typing import Optional, List, Dict, Any
from google.cloud.firestore_v1.base_query import FieldFilter, And, Or

from src.models.attendance import Attendance  # çµ¶å¯¾ãƒ‘ã‚¹ã«ä¿®æ­£
from src.utils.time_utils import get_current_time

class FirestoreRepository:
    def __init__(self, project_id: str, credentials_path: str):
        try:
            cred = credentials.Certificate(credentials_path)
            # ã‚¢ãƒ—ãƒªãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿åˆæœŸåŒ–
            if not firebase_admin._apps:
                firebase_admin.initialize_app(cred, {
                    'projectId': project_id,
                })
            self.db = firestore.client()
            self.attendance_collection = self.db.collection('attendance')
        except Exception as e:
            print(f"Firebase initialization error: {str(e)}")
            raise

    def create_attendance(self, attendance: Attendance) -> None:
        """æ–°ã—ã„å‹¤æ€ è¨˜éŒ²ã‚’ä½œæˆ"""
        doc_ref = self.attendance_collection.document()
        doc_ref.set(attendance.to_dict())

    def get_active_attendance(self, user_id: str) -> Optional[Attendance]:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªï¼ˆçµ‚äº†ã—ã¦ã„ãªã„ï¼‰å‹¤æ€ è¨˜éŒ²ã‚’å–å¾—"""
        query = (
            self.attendance_collection
            .where(filter=firestore.FieldFilter("user_id", "==", user_id))
            .where(filter=firestore.FieldFilter("end_time", "==", None))
            .limit(1)
        )
        docs = query.get()
        
        for doc in docs:
            return Attendance.from_dict(doc.to_dict())
        return None

    def update_attendance(self, attendance: Attendance) -> None:
        """å‹¤æ€ è¨˜éŒ²ã‚’æ›´æ–°"""
        query = (
            self.attendance_collection
            .where(filter=firestore.FieldFilter("user_id", "==", attendance.user_id))
            .where(filter=firestore.FieldFilter("end_time", "==", None))
            .limit(1)
        )
        docs = query.get()
        
        for doc in docs:
            doc.reference.set(attendance.to_dict())
            break

    def get_attendance_by_period(
        self, 
        user_id: str, 
        start_date: datetime, 
        end_date: datetime,
        batch_size: int = 100
    ) -> List[Attendance]:
        """
        æŒ‡å®šæœŸé–“ã®å‹¤æ€ è¨˜éŒ²ã‚’å–å¾—
        
        Args:
            user_id (str): ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
            start_date (datetime): æœŸé–“é–‹å§‹æ—¥æ™‚
            end_date (datetime): æœŸé–“çµ‚äº†æ—¥æ™‚
            batch_size (int): 1å›ã®ã‚¯ã‚¨ãƒªã§å–å¾—ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•°
            
        Returns:
            List[Attendance]: å‹¤æ€ è¨˜éŒ²ã®ãƒªã‚¹ãƒˆ
        
        Raises:
            FirebaseError: Firestoreã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ãŸå ´åˆ
        """
        try:
            # ã‚¯ã‚¨ãƒªã®æ§‹ç¯‰
            query = (
                self.attendance_collection
                .where(filter=FieldFilter("user_id", "==", user_id))
                .where(filter=FieldFilter("start_time", ">=", start_date.isoformat()))
                .where(filter=FieldFilter("start_time", "<=", end_date.isoformat()))
                .order_by("start_time")
                .limit(batch_size)
            )
            
            records = []
            docs = query.get()
            
            # ãƒãƒƒãƒå‡¦ç†ã§ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            while docs:
                records.extend([self._convert_to_attendance(doc) for doc in docs])
                
                # æ¬¡ã®ãƒãƒƒãƒãŒã‚ã‚‹ã‹ç¢ºèª
                last_doc = docs[-1]
                docs = (
                    query
                    .start_after(last_doc)
                    .get()
                )
            
            return records
            
        except Exception as e:
            print(f"Error retrieving attendance records: {str(e)}")
            raise

    def _convert_to_attendance(self, doc: firestore.DocumentSnapshot) -> Attendance:
        """
        Firestoreã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‹¤æ€ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›
        
        Args:
            doc (DocumentSnapshot): Firestoreã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
            
        Returns:
            Attendance: å¤‰æ›ã•ã‚ŒãŸå‹¤æ€ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        """
        data = doc.to_dict()
        return Attendance.from_dict(data)

    def get_attendance_stats(
        self, 
        user_id: str, 
        start_date: datetime, 
        end_date: datetime
    ) -> Dict[str, Any]:
        """
        æŒ‡å®šæœŸé–“ã®å‹¤æ€ çµ±è¨ˆã‚’å–å¾—
        
        Args:
            user_id (str): ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
            start_date (datetime): æœŸé–“é–‹å§‹æ—¥æ™‚
            end_date (datetime): æœŸé–“çµ‚äº†æ—¥æ™‚
            
        Returns:
            Dict[str, Any]: çµ±è¨ˆæƒ…å ±
        """
        records = self.get_attendance_by_period(user_id, start_date, end_date)
        
        total_working_time = 0
        total_break_time = 0
        daily_stats = {}
        
        for record in records:
            date_key = record.start_time.date().isoformat()
            
            if date_key not in daily_stats:
                daily_stats[date_key] = {
                    'working_time': 0,
                    'break_time': 0,
                    'attendance_count': 0
                }
            
            daily_stats[date_key]['working_time'] += record.get_working_time()
            daily_stats[date_key]['break_time'] += record.get_total_break_time()
            daily_stats[date_key]['attendance_count'] += 1
            
            total_working_time += record.get_working_time()
            total_break_time += record.get_total_break_time()
        
        return {
            'total_working_time': total_working_time,
            'total_break_time': total_break_time,
            'daily_stats': daily_stats,
            'record_count': len(records)
        }

================
File: functions/src/services/attendance_service.py
================
from datetime import datetime
from typing import Optional, Tuple

from src.models.attendance import Attendance, BreakPeriod
from src.repositories.firestore_repository import FirestoreRepository
from src.utils.time_utils import get_current_time

class AttendanceService:
    def __init__(self, repository: FirestoreRepository):
        self.repository = repository

    def punch_in(self, user_id: str, user_name: str) -> Tuple[bool, str, Optional[datetime]]:
        """å‡ºå‹¤å‡¦ç†"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if active_attendance:
            return False, "æ—¢ã«å‡ºå‹¤æ¸ˆã¿ã§ã™ã€‚", None

        current_time = get_current_time()
        attendance = Attendance(
            user_id=user_id,
            user_name=user_name,
            start_time=current_time
        )
        self.repository.create_attendance(attendance)
        return True, "å‡ºå‹¤ã‚’è¨˜éŒ²ã—ã¾ã—ãŸã€‚", current_time

    def punch_out(self, user_id: str) -> Tuple[bool, str, Optional[Attendance]]:
        """é€€å‹¤å‡¦ç†"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "å‡ºå‹¤è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", None

        if active_attendance.break_periods and not active_attendance.break_periods[-1].end_time:
            return False, "ä¼‘æ†©ä¸­ã¯é€€å‹¤ã§ãã¾ã›ã‚“ã€‚ã¾ãšä¼‘æ†©ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚", None

        active_attendance.end_time = get_current_time()
        self.repository.update_attendance(active_attendance)
        return True, "é€€å‹¤ã‚’è¨˜éŒ²ã—ã¾ã—ãŸã€‚", active_attendance

    def start_break(self, user_id: str) -> Tuple[bool, str, Optional[datetime]]:
        """ä¼‘æ†©é–‹å§‹å‡¦ç†"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "å‡ºå‹¤è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", None

        if active_attendance.break_periods and not active_attendance.break_periods[-1].end_time:
            return False, "æ—¢ã«ä¼‘æ†©ä¸­ã§ã™ã€‚", None

        current_time = get_current_time()
        active_attendance.break_periods.append(BreakPeriod(start_time=current_time))
        self.repository.update_attendance(active_attendance)
        return True, "ä¼‘æ†©ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚", current_time

    def end_break(self, user_id: str) -> Tuple[bool, str, Optional[Tuple[datetime, float]]]:
        """ä¼‘æ†©çµ‚äº†å‡¦ç†"""
        active_attendance = self.repository.get_active_attendance(user_id)
        if not active_attendance:
            return False, "å‡ºå‹¤è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", None

        if not active_attendance.break_periods or active_attendance.break_periods[-1].end_time:
            return False, "ä¼‘æ†©ãŒé–‹å§‹ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", None

        current_time = get_current_time()
        active_attendance.break_periods[-1].end_time = current_time
        break_duration = active_attendance.break_periods[-1].get_duration()
        
        self.repository.update_attendance(active_attendance)
        return True, "ä¼‘æ†©ã‚’çµ‚äº†ã—ã¾ã—ãŸã€‚", (current_time, break_duration)

================
File: functions/src/services/monthly_summary_service.py
================
from datetime import datetime, timedelta
import calendar
import csv
from io import StringIO
from typing import List, Dict, Any, Tuple

from ..models.attendance import Attendance
from ..repositories.firestore_repository import FirestoreRepository
from ..utils.time_utils import get_current_time, get_start_of_month, get_end_of_month

class MonthlySummaryService:
    def __init__(self, repository: FirestoreRepository):
        self.repository = repository

    def get_monthly_summary(self, user_id: str, year: int, month: int) -> Dict[str, Any]:
        """æŒ‡å®šã•ã‚ŒãŸæœˆã®å‹¤æ€ ã‚µãƒãƒªãƒ¼ã‚’å–å¾—"""
        # æœˆã®é–‹å§‹æ—¥ã¨çµ‚äº†æ—¥ã‚’å–å¾—
        start_date = get_start_of_month(year, month)
        end_date = get_end_of_month(year, month)
        
        # æŒ‡å®šæœˆã®å…¨ã¦ã®å‹¤æ€ è¨˜éŒ²ã‚’å–å¾—
        records = self.repository.get_attendance_by_period(user_id, start_date, end_date)
        
        # æ—¥ã”ã¨ã®å‹¤æ€ è¨˜éŒ²ã‚’é›†è¨ˆ
        daily_records = {}
        weekly_totals = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}  # é€±ã”ã¨ã®åˆè¨ˆæ™‚é–“
        total_working_time = 0
        
        for record in records:
            date = record.start_time.date()
            week_number = (date.day - 1) // 7 + 1
            
            if date not in daily_records:
                daily_records[date] = {
                    'working_time': 0,
                    'break_time': 0,
                    'week_number': week_number
                }
            
            working_time = record.get_working_time()
            break_time = record.get_total_break_time()
            
            daily_records[date]['working_time'] += working_time
            daily_records[date]['break_time'] += break_time
            weekly_totals[week_number] += working_time
            total_working_time += working_time

        return {
            'daily_records': daily_records,
            'weekly_totals': weekly_totals,
            'total_working_time': total_working_time,
            'year': year,
            'month': month
        }

    def generate_csv(self, user_id: str, user_name: str, year: int, month: int) -> Tuple[str, str]:
        """æœˆæ¬¡ã‚µãƒãƒªãƒ¼ã®CSVã‚’ç”Ÿæˆ"""
        summary = self.get_monthly_summary(user_id, year, month)
        
        # CSVãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
        filename = f"attendance_summary_{user_name}_{year}_{month:02d}.csv"
        
        # CSVãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
        output = StringIO()
        writer = csv.writer(output)
        
        # ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’æ›¸ãè¾¼ã¿
        writer.writerow(['å¾“æ¥­å“¡å', user_name])
        writer.writerow(['å¹´æœˆ', f'{year}å¹´{month}æœˆ'])
        writer.writerow([])
        writer.writerow(['æ—¥ä»˜', 'æ›œæ—¥', 'å‹¤å‹™æ™‚é–“', 'ä¼‘æ†©æ™‚é–“', 'é€±ç•ªå·'])
        
        # æ—¥ã€…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã¿
        daily_records = summary['daily_records']
        for date in sorted(daily_records.keys()):
            record = daily_records[date]
            writer.writerow([
                date.strftime('%Y-%m-%d'),
                date.strftime('%A'),
                f"{record['working_time']:.2f}",
                f"{record['break_time']:.2f}",
                record['week_number']
            ])
        
        # é€±æ¬¡ã‚µãƒãƒªãƒ¼ã‚’æ›¸ãè¾¼ã¿
        writer.writerow([])
        writer.writerow(['é€±æ¬¡ã‚µãƒãƒªãƒ¼'])
        for week, total in summary['weekly_totals'].items():
            writer.writerow([f'ç¬¬{week}é€±', f'{total:.2f}'])
        
        # æœˆæ¬¡åˆè¨ˆã‚’æ›¸ãè¾¼ã¿
        writer.writerow([])
        writer.writerow(['æœˆé–“åˆè¨ˆå‹¤å‹™æ™‚é–“', f"{summary['total_working_time']:.2f}"])
        
        return filename, output.getvalue()

================
File: functions/src/slack/commands/attendance_commands.py
================
from typing import Callable
from slack_bolt import App

from src.services.attendance_service import AttendanceService
from src.slack.message_builder import MessageBuilder

class AttendanceCommands:
    def __init__(self, app: App, attendance_service: AttendanceService):
        self.app = app
        self.attendance_service = attendance_service
        self._register_commands()

    def _register_commands(self) -> None:
        """ã™ã¹ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²"""
        self._register_command("/punch_in", self._handle_punch_in)
        self._register_command("/punch_out", self._handle_punch_out)
        self._register_command("/break_begin", self._handle_break_begin)
        self._register_command("/break_end", self._handle_break_end)

    def _register_command(self, command: str, handler: Callable) -> None:
        """å€‹åˆ¥ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²"""
        self.app.command(command)(handler)

    def _handle_punch_in(self, ack, command, say):
        """å‡ºå‹¤ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†"""
        ack()
        
        success, message, time = self.attendance_service.punch_in(
            user_id=command["user_id"],
            user_name=command["user_name"]
        )

        if success:
            blocks = MessageBuilder.create_punch_in_message(
                username=command["user_name"],
                time=time
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    def _handle_punch_out(self, ack, command, say):
        """é€€å‹¤ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†"""
        ack()
        
        success, message, attendance = self.attendance_service.punch_out(
            user_id=command["user_id"]
        )

        if success:
            blocks = MessageBuilder.create_punch_out_message(
                username=command["user_name"],
                time=attendance.end_time,
                working_time=attendance.get_working_time(),
                total_break_time=attendance.get_total_break_time()
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    def _handle_break_begin(self, ack, command, say):
        """ä¼‘æ†©é–‹å§‹ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†"""
        ack()
        
        success, message, time = self.attendance_service.start_break(
            user_id=command["user_id"]
        )

        if success:
            blocks = MessageBuilder.create_break_start_message(
                username=command["user_name"],
                time=time
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        say(
            blocks=blocks,
            channel=command["channel_id"]
        )

    def _handle_break_end(self, ack, command, say):
        """ä¼‘æ†©çµ‚äº†ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†"""
        ack()
        
        success, message, result = self.attendance_service.end_break(
            user_id=command["user_id"]
        )

        if success:
            time, duration = result
            blocks = MessageBuilder.create_break_end_message(
                username=command["user_name"],
                time=time,
                duration=duration
            )
        else:
            blocks = MessageBuilder.create_error_message(message)

        say(
            blocks=blocks,
            channel=command["channel_id"]
        )

================
File: functions/src/slack/commands/summary_commands.py
================
from datetime import datetime
from typing import Dict, Any, List

from slack_bolt import App

from ...services.monthly_summary_service import MonthlySummaryService
from ..message_builder import MessageBuilder

class SummaryCommands:
    def __init__(self, app: App, summary_service: MonthlySummaryService):
        self.app = app
        self.summary_service = summary_service
        self._register_commands()

    def _register_commands(self) -> None:
        """ã™ã¹ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²"""
        self.app.command("/summary")(self._handle_summary)
        self.app.action("select_month")(self._handle_month_selection)
        self.app.action("download_csv")(self._handle_csv_download)

    def _handle_summary(self, ack, body, say):
        """ã‚µãƒãƒªãƒ¼ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†"""
        ack()
        
        current_date = datetime.now()
        # æœˆé¸æŠç”¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—
        blocks = self._create_month_selector_blocks(current_date.year)
        
        say(
            blocks=blocks,
            channel=body["channel_id"]
        )

    def _handle_month_selection(self, ack, body, say):
        """æœˆé¸æŠã®å‡¦ç†"""
        ack()
        
        selected_value = body["actions"][0]["selected_option"]["value"]
        year, month = map(int, selected_value.split("-"))
        
        summary = self.summary_service.get_monthly_summary(
            user_id=body["user"]["id"],
            year=year,
            month=month
        )
        
        blocks = MessageBuilder.create_monthly_summary_message(
            username=body["user"]["name"],
            summary=summary
        )
        
        say(
            blocks=blocks,
            channel=body["channel"]["id"]
        )

    def _handle_csv_download(self, ack, body, client):
        """CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã®å‡¦ç†"""
        ack()
    
        year_month = body["actions"][0]["value"]
        year, month = map(int, year_month.split("-"))
    
        filename, csv_content = self.summary_service.generate_csv(
            user_id=body["user"]["id"],
            user_name=body["user"]["name"],
            year=year,
            month=month
        )
    
        try:
            response = client.files_upload_v2(
                channel=body["channel"]["id"],
                filename=filename,
                content=csv_content,
                title=f"{year}å¹´{month}æœˆã®å‹¤æ€ è¨˜éŒ²",
                initial_comment=f"{year}å¹´{month}æœˆã®å‹¤æ€ è¨˜éŒ²ã‚’CSVã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚"
            )
        
            if not response["ok"]:
                client.chat_postMessage(
                    channel=body["channel"]["id"],
                    text=f"CSVãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸï¼š{response.get('error', 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼')}"
                )
        except Exception as e:
            client.chat_postMessage(
                channel=body["channel"]["id"],
                text=f"CSVãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸï¼š{str(e)}"
            )

    def _create_month_selector_blocks(self, year: int) -> List[Dict[str, Any]]:
        """
        æŒ‡å®šã•ã‚ŒãŸå¹´ã«å¯¾ã—ã¦ã€1æœˆã‹ã‚‰12æœˆã¾ã§ã‚’é¸æŠã§ãã‚‹
        static_selectå½¢å¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã€‚
        """
        options = []
        for m in range(1, 13):
            options.append({
                "text": {
                    "type": "plain_text",
                    "text": f"{m}æœˆ"
                },
                "value": f"{year}-{m}"
            })
        
        blocks = [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"{year}å¹´ã®æœˆã‚’é¸æŠã—ã¦ãã ã•ã„"
                },
                "accessory": {
                    "type": "static_select",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "æœˆã‚’é¸æŠ"
                    },
                    "options": options,
                    "action_id": "select_month"
                }
            }
        ]
        return blocks

================
File: functions/src/slack/store/firestore_installation_store.py
================
from typing import Optional, Dict, Any
import json
from datetime import datetime
from firebase_admin import firestore
from slack_sdk.oauth.installation_store import InstallationStore
from slack_sdk.oauth.installation_store.models.installation import Installation
from slack_sdk.oauth.installation_store.models.bot import Bot

class FirestoreInstallationStore(InstallationStore):
    """Firestoreãƒ™ãƒ¼ã‚¹ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æƒ…å ±æ°¸ç¶šåŒ–ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, db: firestore.Client):
        self.db = db
        self.installations_collection = self.db.collection('slack_installations')
        self.bots_collection = self.db.collection('slack_bots')

    def save(self, installation: Installation):
        """ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æƒ…å ±ã‚’ä¿å­˜"""
        # åŸºæœ¬ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æƒ…å ±ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚ã‚Šã®å ´åˆï¼‰
        installation_data = {
            'app_id': installation.app_id,
            'enterprise_id': installation.enterprise_id,
            'team_id': installation.team_id,
            'user_id': installation.user_id,
            'bot_token': installation.bot_token,
            'bot_id': installation.bot_id,
            'bot_user_id': installation.bot_user_id,
            'bot_scopes': installation.bot_scopes,
            'user_token': installation.user_token,
            'user_scopes': installation.user_scopes,
            'installed_at': datetime.utcnow(),
            'is_enterprise_install': installation.is_enterprise_install,
        }

        # ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚ã‚Šãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆID
        user_doc_id = self._generate_installation_id(
            enterprise_id=installation.enterprise_id,
            team_id=installation.team_id,
            is_enterprise_install=installation.is_enterprise_install,
            user_id=installation.user_id
        )
        self.installations_collection.document(user_doc_id).set(installation_data)

        # ãƒœãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ãŒã‚ã‚‹å ´åˆã€user_idãªã—ã®ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹/ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºå˜ä½ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚‚ä¿å­˜ã™ã‚‹
        # ã“ã‚Œã«ã‚ˆã‚Šã€user_idã‚’æŒ‡å®šã—ãªãã¦ã‚‚botã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æƒ…å ±ãŒå–å¾—å¯èƒ½ã«ãªã‚‹
        if installation.bot_token:
            bot_level_doc_id = self._generate_installation_id(
                enterprise_id=installation.enterprise_id,
                team_id=installation.team_id,
                is_enterprise_install=installation.is_enterprise_install,
                user_id=None  # userãªã—
            )
            bot_level_data = dict(installation_data)
            bot_level_data['user_id'] = None
            self.installations_collection.document(bot_level_doc_id).set(bot_level_data)

            # Botæƒ…å ±ã‚‚ä¿å­˜
            bot_data = {
                'app_id': installation.app_id,
                'enterprise_id': installation.enterprise_id,
                'team_id': installation.team_id,
                'bot_token': installation.bot_token,
                'bot_id': installation.bot_id,
                'bot_user_id': installation.bot_user_id,
                'bot_scopes': installation.bot_scopes,
                'installed_at': datetime.utcnow(),
                'is_enterprise_install': installation.is_enterprise_install,
            }
            
            bot_doc_id = self._generate_bot_id(
                enterprise_id=installation.enterprise_id,
                team_id=installation.team_id,
                is_enterprise_install=installation.is_enterprise_install
            )
            self.bots_collection.document(bot_doc_id).set(bot_data)

    def find_installation(
        self,
        *,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        user_id: Optional[str] = None,
        is_enterprise_install: Optional[bool] = False,
    ) -> Optional[Installation]:
        """ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æƒ…å ±ã‚’æ¤œç´¢"""
        doc_id = self._generate_installation_id(
            enterprise_id=enterprise_id,
            team_id=team_id,
            is_enterprise_install=is_enterprise_install,
            user_id=user_id
        )
        
        doc = self.installations_collection.document(doc_id).get()
        if not doc.exists:
            # user_idãªã—ã§æ¤œç´¢ã§ããªã‹ã£ãŸå ´åˆã€user_idãŒNoneã§ãªã„ãªã‚‰å†åº¦Noneã§æ¤œç´¢
            # ãŸã ã—Slack Boltã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§user_idç„¡ã—æ¤œç´¢ã‚’è¡Œã†ã“ã¨ãŒå¤šã„ã®ã§ã€
            # user_idãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã“ã‚Œä»¥ä¸Šå†æ¤œç´¢ã¯ä¸è¦ã€‚
            if user_id is not None:
                # user_idãŒã‚ã‚‹æ¤œç´¢ã§è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã€user_idãªã—ã§å†æ¤œç´¢ã—ã¦ã¿ã‚‹
                no_user_doc_id = self._generate_installation_id(
                    enterprise_id=enterprise_id,
                    team_id=team_id,
                    is_enterprise_install=is_enterprise_install,
                    user_id=None
                )
                doc = self.installations_collection.document(no_user_doc_id).get()
                if not doc.exists:
                    return None
                return self._create_installation_from_doc(doc)
            return None
            
        return self._create_installation_from_doc(doc)

    def find_bot(
        self,
        *,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        is_enterprise_install: Optional[bool] = False
    ) -> Optional[Bot]:
        """Botæƒ…å ±ã‚’æ¤œç´¢"""
        doc_id = self._generate_bot_id(
            enterprise_id=enterprise_id,
            team_id=team_id,
            is_enterprise_install=is_enterprise_install
        )
        
        doc = self.bots_collection.document(doc_id).get()
        if not doc.exists:
            return None
            
        return self._create_bot_from_doc(doc)

    def delete_installation(
        self,
        *,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        user_id: Optional[str] = None,
        is_enterprise_install: Optional[bool] = False
    ) -> None:
        """ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æƒ…å ±ã‚’å‰Šé™¤"""
        doc_id = self._generate_installation_id(
            enterprise_id=enterprise_id,
            team_id=team_id,
            is_enterprise_install=is_enterprise_install,
            user_id=user_id
        )
        
        self.installations_collection.document(doc_id).delete()

        # ãƒœãƒƒãƒˆãƒ¬ãƒ™ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚‚å‰Šé™¤
        if user_id is not None:
            bot_level_doc_id = self._generate_installation_id(
                enterprise_id=enterprise_id,
                team_id=team_id,
                is_enterprise_install=is_enterprise_install,
                user_id=None
            )
            self.installations_collection.document(bot_level_doc_id).delete()

    def delete_bot(
        self,
        *,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        is_enterprise_install: Optional[bool] = False
    ) -> None:
        """Botæƒ…å ±ã‚’å‰Šé™¤"""
        doc_id = self._generate_bot_id(
            enterprise_id=enterprise_id,
            team_id=team_id,
            is_enterprise_install=is_enterprise_install
        )
        
        self.bots_collection.document(doc_id).delete()

    def _generate_installation_id(
        self,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        is_enterprise_install: bool,
        user_id: Optional[str]
    ) -> str:
        """ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æƒ…å ±ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆIDç”Ÿæˆ"""
        components = []
        if is_enterprise_install and enterprise_id:
            # ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã®å ´åˆ
            components.append(f"E{enterprise_id}")
            if user_id:
                components.append(f"U{user_id}")
        else:
            # é€šå¸¸ã®ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
            if enterprise_id:
                components.append(f"E{enterprise_id}")
            if team_id:
                components.append(f"T{team_id}")
            if user_id:
                components.append(f"U{user_id}")
        return "-".join(components)

    def _generate_bot_id(
        self,
        enterprise_id: Optional[str],
        team_id: Optional[str],
        is_enterprise_install: bool
    ) -> str:
        """Botã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆIDç”Ÿæˆ"""
        components = []
        if is_enterprise_install and enterprise_id:
            components.append(f"E{enterprise_id}")
        else:
            if enterprise_id:
                components.append(f"E{enterprise_id}")
            if team_id:
                components.append(f"T{team_id}")
        return "-".join(components)

    def _create_installation_from_doc(self, doc) -> Installation:
        """Firestoreãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‹ã‚‰Installationã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ"""
        data = doc.to_dict()
        return Installation(
            app_id=data.get('app_id'),
            enterprise_id=data.get('enterprise_id'),
            team_id=data.get('team_id'),
            user_id=data.get('user_id'),
            bot_token=data.get('bot_token'),
            bot_id=data.get('bot_id'),
            bot_user_id=data.get('bot_user_id'),
            bot_scopes=data.get('bot_scopes', []),
            user_token=data.get('user_token'),
            user_scopes=data.get('user_scopes', []),
            is_enterprise_install=data.get('is_enterprise_install', False)
        )

    def _create_bot_from_doc(self, doc) -> Bot:
        """Firestoreãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‹ã‚‰Botã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ"""
        data = doc.to_dict()
        return Bot(
            app_id=data.get('app_id'),
            enterprise_id=data.get('enterprise_id'),
            team_id=data.get('team_id'),
            bot_token=data.get('bot_token'),
            bot_id=data.get('bot_id'),
            bot_user_id=data.get('bot_user_id'),
            bot_scopes=data.get('bot_scopes', []),
            is_enterprise_install=data.get('is_enterprise_install', False)
        )

================
File: functions/src/slack/store/firestore_state_store.py
================
from datetime import datetime, timedelta
from typing import Optional
from firebase_admin import firestore
from slack_sdk.oauth.state_store import OAuthStateStore
import secrets

class FirestoreStateStore(OAuthStateStore):
    """Firestoreãƒ™ãƒ¼ã‚¹ã®èªè¨¼çŠ¶æ…‹ç®¡ç†ã‚¯ãƒ©ã‚¹"""
    
    def __init__(
        self,
        db: firestore.Client,
        expiration_seconds: int = 600
    ):
        self.db = db
        self.expiration_seconds = expiration_seconds
        self.states_collection = self.db.collection('slack_oauth_states')

    def issue(self, expire_in: Optional[int] = None) -> str:
        """
        æ–°ã—ã„stateã‚’ç™ºè¡Œã—ã¦è¿”ã™
        
        Boltã®OAuthStateStoreã§expectã•ã‚Œã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹:
        issue()ã¯å¼•æ•°ãªã—ã§å‘¼ã°ã‚Œã€stateæ–‡å­—åˆ—ã‚’è¿”ã™ã“ã¨ãŒæ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚
        """
        if expire_in is None:
            expire_in = self.expiration_seconds
            
        # ãƒ©ãƒ³ãƒ€ãƒ ãªstateã‚’ç”Ÿæˆ
        state = secrets.token_urlsafe(32)
        expire_at = datetime.utcnow() + timedelta(seconds=expire_in)
        
        try:
            self.states_collection.document(state).set({
                'state': state,
                'expire_at': expire_at
            })
            return state
        except Exception as e:
            print(f"Error issuing state: {str(e)}")
            # ã‚¨ãƒ©ãƒ¼æ™‚ã¯ç©ºæ–‡å­—åˆ—ãªã©è¿”ã—ã¦ã‚‚ã‚ˆã„ãŒã€åŸºæœ¬çš„ã«ã¯raiseã™ã‚‹
            raise

    def consume(self, state: str) -> bool:
        """
        çŠ¶æ…‹ã‚’æ¤œè¨¼ã—ã¦æ¶ˆè²»
        
        Args:
            state: æ¤œè¨¼ã™ã‚‹stateæ–‡å­—åˆ—
            
        Returns:
            bool: æ¤œè¨¼ãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹
        """
        try:
            doc_ref = self.states_collection.document(state)
            doc = doc_ref.get()
            
            if not doc.exists:
                return False
                
            data = doc.to_dict()
            expire_at = data.get('expire_at')
            
            if expire_at and expire_at.replace(tzinfo=None) < datetime.utcnow():
                doc_ref.delete()
                return False
                
            doc_ref.delete()
            return True
        except Exception as e:
            print(f"Error consuming state: {str(e)}")
            return False

================
File: functions/src/slack/app.py
================
from firebase_admin import firestore
from flask import Request, Response
from slack_bolt import App
from slack_bolt.adapter.flask import SlackRequestHandler
import json
import secrets
import os

from src.services.attendance_service import AttendanceService
from src.services.monthly_summary_service import MonthlySummaryService
from src.slack.commands.attendance_commands import AttendanceCommands
from src.slack.commands.summary_commands import SummaryCommands
from src.slack.oauth import setup_oauth_flow
from src.repositories.firestore_repository import FirestoreRepository
from src.config import get_config

def create_slack_bot_function(request: Request) -> Response:
    """Create and return the Slack bot function"""
    try:
        # Get configuration
        config = get_config()
        
        # Initialize Firebase repository
        firebase_repo = FirestoreRepository(
            project_id=config.firebase.project_id,
            credentials_path=config.firebase.credentials_path
        )
        
        # Initialize services
        attendance_service = AttendanceService(firebase_repo)
        monthly_summary_service = MonthlySummaryService(firebase_repo)
        
        # Setup OAuth with Firestore-based stores
        # OAuthSettingsã§install_path, redirect_uri_path, success_url, failure_urlã‚’æŒ‡å®šæ¸ˆã¿
        oauth_settings = setup_oauth_flow(
            client_id=config.slack.client_id,
            client_secret=config.slack.client_secret,
            db=firestore.client()
        )
        
        # Initialize Slack app with OAuth
        app = App(oauth_settings=oauth_settings)
        
        # Register commands
        AttendanceCommands(app, attendance_service)
        SummaryCommands(app, monthly_summary_service)
        
        # Initialize handler
        handler = SlackRequestHandler(app)
        
        path = request.path
        method = request.method

        # æˆåŠŸãƒ»å¤±æ•—æ™‚ã®URLã¯Slack BoltãŒOAuthå®Œäº†å¾Œã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã™ã‚‹ã€‚
        # ã“ã“ã§ã¯é™çš„ãªãƒšãƒ¼ã‚¸ã‚’è¿”ã™ã®ã¿ã§ã€handler.handle()ã‚’å‘¼ã°ãªã„ã€‚
        if method == "GET" and path == "/slack/oauth_success":
            # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æˆåŠŸå¾Œã®é™çš„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            return Response(
                "<html><body><h1>ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒå®Œäº†ã—ã¾ã—ãŸï¼</h1>"
                "<p>ã“ã®ãƒšãƒ¼ã‚¸ã‚’é–‰ã˜ã€Slackãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã§ãƒœãƒƒãƒˆã‚’ãŠä½¿ã„ãã ã•ã„ã€‚</p></body></html>",
                status=200,
                mimetype='text/html'
            )
        
        if method == "GET" and path == "/slack/oauth_failure":
            error = request.args.get("error", "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼")
            # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¤±æ•—æ™‚ã®é™çš„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            return Response(
                f"<html><body><h1>ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã«å¤±æ•—ã—ã¾ã—ãŸ</h1>"
                f"<p>ã‚¨ãƒ©ãƒ¼: {error}</p>"
                f"<p><a href='/slack/install'>å†åº¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚’è©¦ã¿ã‚‹</a></p></body></html>",
                status=400,
                mimetype='text/html'
            )

        # ãã‚Œä»¥å¤–ã®URLï¼ˆ/slack/install, /slack/oauth_redirect å«ã‚€ï¼‰ã¯
        # handler.handle(request)ã§Slack Boltã«å‡¦ç†ã‚’å§”è­²
        # Boltã¯install_path, redirect_uri_pathã«å¯¾å¿œã™ã‚‹GETå‡¦ç†ã‚’å†…éƒ¨çš„ã«è¡Œã†
        return handler.handle(request)
        
    except Exception as e:
        print(f"Error in create_slack_bot_function: {str(e)}")
        return Response(
            json.dumps({
                "error": "Internal Server Error",
                "message": str(e)
            }),
            status=500,
            mimetype='application/json'
        )

================
File: functions/src/slack/message_builder.py
================
from datetime import datetime
from typing import List, Dict, Any

class MessageBuilder:
    @staticmethod
    def format_time(dt: datetime) -> str:
        """æ™‚åˆ»ã‚’è¦‹ã‚„ã™ã„å½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        return dt.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def format_duration(minutes: float) -> str:
        """æ™‚é–“ã‚’æ™‚é–“ã¨åˆ†ã®å½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        hours = int(minutes // 60)
        mins = int(minutes % 60)
        if hours > 0:
            return f"{hours}æ™‚é–“{mins}åˆ†"
        return f"{mins}åˆ†"

    @staticmethod
    def create_punch_in_message(username: str, time: datetime) -> List[Dict[str, Any]]:
        """å‡ºå‹¤ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "ğŸƒ å‡ºå‹¤è¨˜éŒ²",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å¾“æ¥­å“¡:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*å‡ºå‹¤æ™‚åˆ»:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "ä»Šæ—¥ã‚‚ä¸€æ—¥é ‘å¼µã‚Šã¾ã—ã‚‡ã†ï¼ ğŸ‘"
                    }
                ]
            }
        ]

    @staticmethod
    def create_punch_out_message(username: str, time: datetime, working_time: float, total_break_time: float) -> List[Dict[str, Any]]:
        """é€€å‹¤ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "ğŸƒâ€â™‚ï¸ é€€å‹¤è¨˜éŒ²",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å¾“æ¥­å“¡:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*é€€å‹¤æ™‚åˆ»:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å®Ÿåƒæ™‚é–“:*\n{MessageBuilder.format_duration(working_time)}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*ä¼‘æ†©æ™‚é–“:*\n{MessageBuilder.format_duration(total_break_time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼ ğŸŒŸ"
                    }
                ]
            }
        ]

    @staticmethod
    def create_break_start_message(username: str, time: datetime) -> List[Dict[str, Any]]:
        """ä¼‘æ†©é–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "â˜•ï¸ ä¼‘æ†©é–‹å§‹",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å¾“æ¥­å“¡:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*é–‹å§‹æ™‚åˆ»:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "ã‚†ã£ãã‚Šä¼‘æ†©ã—ã¦ãã ã•ã„ ğŸµ"
                    }
                ]
            }
        ]

    @staticmethod
    def create_break_end_message(username: str, time: datetime, duration: float) -> List[Dict[str, Any]]:
        """ä¼‘æ†©çµ‚äº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        return [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "â° ä¼‘æ†©çµ‚äº†",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å¾“æ¥­å“¡:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*çµ‚äº†æ™‚åˆ»:*\n{MessageBuilder.format_time(time)}"
                    }
                ]
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*ä¼‘æ†©æ™‚é–“:*\n{MessageBuilder.format_duration(duration)}"
                    }
                ]
            },
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "ãã‚Œã§ã¯ã€ä»•äº‹ã«æˆ»ã‚Šã¾ã—ã‚‡ã†ï¼ ğŸ’ª"
                    }
                ]
            }
        ]

    @staticmethod
    def create_error_message(error_message: str) -> List[Dict[str, Any]]:
        """ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        return [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"âš ï¸ *ã‚¨ãƒ©ãƒ¼*: {error_message}"
                }
            }
        ]
    
    @staticmethod
    def create_monthly_summary_message(username: str, summary: Dict[str, Any]) -> List[Dict[str, Any]]:
        """æœˆæ¬¡ã‚µãƒãƒªãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ"""
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"ğŸ“Š {summary['year']}å¹´{summary['month']}æœˆã®å‹¤æ€ ã‚µãƒãƒªãƒ¼",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*å¾“æ¥­å“¡:*\n{username}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*æœˆé–“åˆè¨ˆå‹¤å‹™æ™‚é–“:*\n{MessageBuilder.format_duration(summary['total_working_time'])}"
                    }
                ]
            },
            {
                "type": "divider"
            }
        ]

        # é€±æ¬¡ã‚µãƒãƒªãƒ¼ã‚’è¿½åŠ 
        weekly_fields = []
        for week, total in summary['weekly_totals'].items():
            weekly_fields.append({
                "type": "mrkdwn",
                "text": f"*ç¬¬{week}é€±:*\n{MessageBuilder.format_duration(total)}"
            })

        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": "*é€±æ¬¡ã‚µãƒãƒªãƒ¼*"
            }
        })

        blocks.append({
            "type": "section",
            "fields": weekly_fields
        })

        # CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
        blocks.extend([
            {
                "type": "divider"
            },
            {
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "CSVã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
                            "emoji": True
                        },
                        "value": f"{summary['year']}-{summary['month']}",
                        "action_id": "download_csv",
                        "style": "primary"
                    }
                ]
            }
        ])

        return blocks

================
File: functions/src/slack/oauth.py
================
# src/slack/oauth.py

import os
from slack_bolt.oauth.oauth_settings import OAuthSettings
from firebase_admin import firestore
from .store.firestore_installation_store import FirestoreInstallationStore
from .store.firestore_state_store import FirestoreStateStore

def setup_oauth_flow(client_id: str, client_secret: str, db: firestore.Client):
    """OAuthãƒ•ãƒ­ãƒ¼ã®è¨­å®šã‚’è¡Œã†"""
    
    # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æƒ…å ±ã¨çŠ¶æ…‹ç®¡ç†ç”¨ã®ã‚¹ãƒˆã‚¢ã‚’åˆæœŸåŒ–
    installation_store = FirestoreInstallationStore(db)
    state_store = FirestoreStateStore(db)

    # ã‚¹ã‚³ãƒ¼ãƒ—è¨­å®š
    # 'bot'ã‚¹ã‚³ãƒ¼ãƒ—ã‚’å‰Šé™¤ã—ã€'files:write:user'ã‚’ä½¿ç”¨
    SCOPES = [
        "chat:write",
        "commands",
        "files:write",
        "users:read",
        "users:read.email"
    ]

    base_url = os.getenv("SLACK_APP_BASE_URL", "https://slack-bot-function-2vwbe2ah2q-uc.a.run.app")
    
    oauth_settings = OAuthSettings(
        client_id=client_id,
        client_secret=client_secret,
        scopes=SCOPES,
        installation_store=installation_store,
        state_store=state_store,
        install_path="/slack/install",
        redirect_uri_path="/slack/oauth_redirect",
        redirect_uri=f"{base_url}/slack/oauth_redirect",
        success_url="/slack/oauth_success",
        failure_url="/slack/oauth_failure"
    )
    
    return oauth_settings

================
File: functions/src/utils/time_utils.py
================
from datetime import datetime, timedelta
import calendar
import pytz

from ..config import get_config

def get_current_time() -> datetime:
    """ç¾åœ¨æ™‚åˆ»ã‚’è¨­å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã§å–å¾—"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    return datetime.now(timezone)

def get_start_of_month(year: int, month: int) -> datetime:
    """æœˆåˆæ—¥ã®0æ™‚0åˆ†ã‚’å–å¾—"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    return datetime(year, month, 1, 0, 0, 0, tzinfo=timezone)

def get_end_of_month(year: int, month: int) -> datetime:
    """æœˆæœ«æ—¥ã®23æ™‚59åˆ†59ç§’ã‚’å–å¾—"""
    config = get_config()
    timezone = pytz.timezone(config.application.timezone)
    
    # æœˆæœ«æ—¥ã‚’å–å¾—
    _, last_day = calendar.monthrange(year, month)
    
    return datetime(year, month, last_day, 23, 59, 59, tzinfo=timezone)

def get_week_number(date: datetime) -> int:
    """æ—¥ä»˜ã‹ã‚‰é€±ç•ªå·ã‚’å–å¾—ï¼ˆ1-5ï¼‰"""
    return (date.day - 1) // 7 + 1

================
File: functions/src/config.py
================
import os
from pathlib import Path
from typing import Any
from dotenv import load_dotenv

from omegaconf import OmegaConf

_config = None

def init_config() -> Any:
    """è¨­å®šã‚’åˆæœŸåŒ–"""
    global _config
    
    if _config is not None:
        return _config

    # .envãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
    load_dotenv()
    
    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
    config_path = Path(__file__).parent.parent / "config" / "config.yaml"
    
    # åŸºæœ¬è¨­å®šã®èª­ã¿è¾¼ã¿
    _config = OmegaConf.load(config_path)
    
    # ç’°å¢ƒå¤‰æ•°ã§ä¸Šæ›¸ã
    env_config = OmegaConf.create({
        "slack": {
            "bot_token": os.getenv("SLACK_BOT_TOKEN"),
            "signing_secret": os.getenv("SLACK_SIGNING_SECRET"),
            "app_token": os.getenv("SLACK_APP_TOKEN"),
            "client_id": os.getenv("SLACK_CLIENT_ID"),
            "client_secret": os.getenv("SLACK_CLIENT_SECRET")
        },
        "firebase": {
            "project_id": os.getenv("APP_FIREBASE_PROJECT_ID"),
            "credentials_path": os.getenv("APP_FIREBASE_CREDENTIALS_PATH"),
        }
    })
    
    _config = OmegaConf.merge(_config, env_config)
    return _config

def get_config() -> Any:
    """è¨­å®šã‚’å–å¾—"""
    global _config
    if _config is None:
        _config = init_config()
    return _config

================
File: functions/src/main.py
================
import asyncio
from flask import Flask, request
import functions_framework
from slack_bolt.adapter.socket_mode.async_handler import AsyncSocketModeHandler

from src.config import init_config
from src.repositories.firestore_repository import FirestoreRepository
from src.services.attendance_service import AttendanceService
from src.services.monthly_summary_service import MonthlySummaryService
from src.slack.app import SlackApp

# Configuration
config = init_config()

print("Initializing services...")

# Initialize repositories
firestore_repo = FirestoreRepository(
    project_id=config.firebase.project_id,
    credentials_path=config.firebase.credentials_path
)

# Initialize services
attendance_service = AttendanceService(firestore_repo)
monthly_summary_service = MonthlySummaryService(firestore_repo)  # è¿½åŠ 

print("Initializing Slack app...")

# Initialize Slack app
slack_app = SlackApp(
    bot_token=config.slack.bot_token,
    signing_secret=config.slack.signing_secret,
    app_token=config.slack.app_token,
    attendance_service=attendance_service,
    monthly_summary_service=monthly_summary_service  # è¿½åŠ 
)

app = Flask(__name__)
handler = slack_app.get_handler()

@functions_framework.http
def slack_bot(request):
    """Cloud Functionsç”¨ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ"""
    if request.method == "POST":
        # Slackã‹ã‚‰ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†
        return handler.handle(request)
    return "Method not allowed", 405

async def start_socket_mode():
    """Socket Modeãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®èµ·å‹•"""
    try:
        app_handler = AsyncSocketModeHandler(
            app=slack_app.get_app(),
            app_token=config.slack.app_token
        )
        await app_handler.start_async()
    except Exception as e:
        print(f"Error starting socket mode: {e}")
        raise

if __name__ == "__main__":
    print("Starting socket mode...")
    # ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç”¨
    # Socket Modeã®å ´åˆ
    asyncio.run(start_socket_mode())

================
File: functions/main.py
================
import os
import json
from dotenv import load_dotenv
from firebase_functions import https_fn
from firebase_admin import initialize_app, credentials

from src.slack.app import create_slack_bot_function

# ç’°å¢ƒå¤‰æ•°ã®èª­ã¿è¾¼ã¿
load_dotenv()

# Firebaseèªè¨¼æƒ…å ±ã®è¨­å®š
try:
    cred_path = os.getenv('APP_FIREBASE_CREDENTIALS_PATH')
    if not cred_path:
        raise ValueError("Firebase credentials path not set in environment variables")
    
    if not os.path.exists(cred_path):
        raise FileNotFoundError(f"Firebase credentials file not found at: {cred_path}")
    
    cred = credentials.Certificate(cred_path)
    initialize_app(cred)
except Exception as e:
    print(f"Firebase initialization error: {str(e)}")
    raise

@https_fn.on_request()
def slack_bot_function(request: https_fn.Request) -> https_fn.Response:
    """
    Slackãƒœãƒƒãƒˆã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆé–¢æ•°
    
    Args:
        request: Cloud Functionsã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        
    Returns:
        Response: Cloud Functionsã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    """
    try:
        # å…¨ã¦ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯create_slack_bot_functionã§å‡¦ç†
        return create_slack_bot_function(request)
    except Exception as e:
        print(f"Error in slack_bot_function: {str(e)}")
        return https_fn.Response(
            json.dumps({
                "error": "Internal Server Error",
                "message": str(e)
            }),
            status=500,
            mimetype='application/json'
        )

================
File: functions/requirements.txt
================
firebase-functions==0.4.2
firebase-admin>=6.2.0
slack-bolt>=1.18.0
slack-sdk>=3.21.3
omegaconf>=2.3.0
python-dateutil>=2.8.2
pytz>=2023.3
aiohttp>=3.8.5
functions-framework>=3.4.0
flask>=2.3.3
python-dotenv>=1.0.0

================
File: .firebaserc
================
{
  "projects": {
    "default": "slack-attendance-bot-4a3a5"
  },
  "targets": {},
  "etags": {}
}

================
File: .gitignore
================
**.log
**.json
.env
config/firebase-credentials.json
.env
__pycache__
*.pyc
*venv
data/installations/
data/states/

================
File: firestore.rules
================
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // å‹¤æ€ è¨˜éŒ²ã®ãƒ«ãƒ¼ãƒ«
    match /attendance/{document} {
      allow read, write: if request.auth != null;
      
      // æœˆæ¬¡ãƒ‡ãƒ¼ã‚¿å–å¾—ã®ãŸã‚ã®è¤‡æ•°ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆèª­ã¿å–ã‚Šè¨±å¯
      allow list: if request.auth != null 
        && request.query.limit <= 1000
        && request.query.orderBy == "start_time";
    }

    // Slackã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æƒ…å ±ã®ãƒ«ãƒ¼ãƒ«
    match /slack_installations/{installationId} {
      // Cloud Functions ã‹ã‚‰ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
      allow read, write: if request.auth.token.firebase.sign_in_provider == 'google.com'
        && request.auth.token.firebase.sign_in_provider == 'service_account';
    }

    // Slackãƒœãƒƒãƒˆæƒ…å ±ã®ãƒ«ãƒ¼ãƒ«
    match /slack_bots/{botId} {
      // Cloud Functions ã‹ã‚‰ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
      allow read, write: if request.auth.token.firebase.sign_in_provider == 'google.com'
        && request.auth.token.firebase.sign_in_provider == 'service_account';
    }

    // OAuthçŠ¶æ…‹ç®¡ç†ã®ãƒ«ãƒ¼ãƒ«
    match /slack_oauth_states/{stateId} {
      // Cloud Functions ã‹ã‚‰ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
      allow read, write: if request.auth.token.firebase.sign_in_provider == 'google.com'
        && request.auth.token.firebase.sign_in_provider == 'service_account';
    }

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ«ãƒ¼ãƒ«
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
